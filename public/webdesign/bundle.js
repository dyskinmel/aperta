/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./views/webdesign.js":
/*!****************************!*\
  !*** ./views/webdesign.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _webdesign_WebDesign_svelte__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webdesign/WebDesign.svelte */ \"./views/webdesign/WebDesign.svelte\");\n\nvar webDesign = new _webdesign_WebDesign_svelte__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n  target: document.body\n});\n\n//# sourceURL=webpack://aperta/./views/webdesign.js?");

/***/ }),

/***/ "./views/webdesign/RightSideMenu/ConnectionEditor/CMSClient.js":
/*!*********************************************************************!*\
  !*** ./views/webdesign/RightSideMenu/ConnectionEditor/CMSClient.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ContentfulClient\": () => (/* binding */ ContentfulClient)\n/* harmony export */ });\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n//working on migrating features from CMSConnector.js\nvar CmsClient = /*#__PURE__*/_createClass(function CmsClient() {\n  _classCallCheck(this, CmsClient);\n});\nvar ContentfulClient = /*#__PURE__*/function (_CmsClient) {\n  _inherits(ContentfulClient, _CmsClient);\n  var _super = _createSuper(ContentfulClient);\n  function ContentfulClient() {\n    var _this;\n    _classCallCheck(this, ContentfulClient);\n    _this = _super.call(this);\n    _this.BASE_URL = \"https://cdn.contentful.com\";\n\n    // TODO: change following to use environment variables in the future\n    _this.spaceId = \"rvj0gs4gb6wz\";\n    _this.environmentId = \"master\";\n    _this.accessToken = \"\";\n    _this.contentTypes = null;\n    _this.contents = null;\n    _this.entries = null;\n    _this.getApiKey();\n    return _this;\n  }\n  _createClass(ContentfulClient, [{\n    key: \"getApiKey\",\n    value: function () {\n      var _getApiKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var url, response, apiKey;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              url = \"http://localhost:9000/api/apiKey\";\n              _context.prev = 1;\n              _context.next = 4;\n              return fetch(url);\n            case 4:\n              response = _context.sent;\n              if (response.ok) {\n                _context.next = 7;\n                break;\n              }\n              throw new Error(\"Network response was not ok.\");\n            case 7:\n              _context.next = 9;\n              return response.text();\n            case 9:\n              apiKey = _context.sent;\n              return _context.abrupt(\"return\", apiKey);\n            case 13:\n              _context.prev = 13;\n              _context.t0 = _context[\"catch\"](1);\n              console.error(\"error:\", _context.t0);\n            case 16:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, null, [[1, 13]]);\n      }));\n      function getApiKey() {\n        return _getApiKey.apply(this, arguments);\n      }\n      return getApiKey;\n    }()\n  }, {\n    key: \"getContentType\",\n    value: function () {\n      var _getContentType = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var url, response, contentTypeJSON;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return this.getApiKey();\n            case 2:\n              this.accessToken = _context2.sent;\n              url = \"https://cdn.contentful.com/spaces/\" + this.spaceId + \"/environments/\" + this.environmentId + \"/content_types?access_token=\" + this.accessToken;\n              _context2.next = 6;\n              return fetch(url);\n            case 6:\n              response = _context2.sent;\n              _context2.next = 9;\n              return response.json();\n            case 9:\n              contentTypeJSON = _context2.sent;\n              this.contentTypes = JSON.parse(JSON.stringify(contentTypeJSON));\n              // console.log(this.contentTypes);\n              return _context2.abrupt(\"return\", this.contentTypes);\n            case 12:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function getContentType() {\n        return _getContentType.apply(this, arguments);\n      }\n      return getContentType;\n    }()\n  }, {\n    key: \"getContents\",\n    value: function () {\n      var _getContents = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(contentType) {\n        var url, response, entries;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.next = 2;\n              return this.getApiKey();\n            case 2:\n              this.accessToken = _context3.sent;\n              url = \"https://cdn.contentful.com/spaces/\" + this.spaceId + \"/environments/\" + this.environmentId + \"/entries?access_token=\" + this.accessToken + \"&content_type=\" + contentType;\n              _context3.next = 6;\n              return fetch(url);\n            case 6:\n              response = _context3.sent;\n              _context3.next = 9;\n              return response.json();\n            case 9:\n              entries = _context3.sent;\n              this.contents = JSON.parse(JSON.stringify(entries));\n              // console.log(this.content);\n              return _context3.abrupt(\"return\", this.contents);\n            case 12:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function getContents(_x) {\n        return _getContents.apply(this, arguments);\n      }\n      return getContents;\n    }()\n  }, {\n    key: \"getEntry\",\n    value: function () {\n      var _getEntry = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(content) {\n        var url, response, entries;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              _context4.next = 2;\n              return this.getApiKey();\n            case 2:\n              this.accessToken = _context4.sent;\n              url = \"https://cdn.contentful.com/spaces/\" + this.spaceId + \"/environments/\" + this.environmentId + \"/entries/\" + content + \"?access_token=\" + this.accessToken;\n              _context4.next = 6;\n              return fetch(url);\n            case 6:\n              response = _context4.sent;\n              _context4.next = 9;\n              return response.json();\n            case 9:\n              entries = _context4.sent;\n              this.entries = JSON.parse(JSON.stringify(entries));\n              // console.log(this.entries);\n              return _context4.abrupt(\"return\", this.entries);\n            case 12:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this);\n      }));\n      function getEntry(_x2) {\n        return _getEntry.apply(this, arguments);\n      }\n      return getEntry;\n    }()\n  }]);\n  return ContentfulClient;\n}(CmsClient);\n\n//# sourceURL=webpack://aperta/./views/webdesign/RightSideMenu/ConnectionEditor/CMSClient.js?");

/***/ }),

/***/ "./views/webdesign/Utils/CssStyleManager.js":
/*!**************************************************!*\
  !*** ./views/webdesign/Utils/CssStyleManager.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CssStyleManager\": () => (/* binding */ CssStyleManager)\n/* harmony export */ });\nObject(function webpackMissingModule() { var e = new Error(\"Cannot find module '../utils.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n/* harmony import */ var specificity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! specificity */ \"./node_modules/specificity/dist/specificity.mjs\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n//this js will read/write css style from/to css file and html file\n\n\n\n\n/* \n    *  CssStyleManager class\n    *  This class will read/write css style from/to css file and html file(inline style)\n*/\n\nvar CssStyleManager = /*#__PURE__*/function () {\n  function CssStyleManager() {\n    _classCallCheck(this, CssStyleManager);\n    //initialize\n\n    //get canvas document and selected element\n    this.canvasWrapper = new Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../utils.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())();\n    this.canvasDocument = this.canvasWrapper.getCanvasDocument();\n    this.selectedElm = this.canvasWrapper.getSelectedElement();\n\n    //set element related variables\n    this.elmStyle = this.selectedElm.style;\n    this.elmId = this.selectedElm.id;\n    this.elmClassList = this.selectedElm.classList;\n    this.elmTagName = this.selectedElm.tagName;\n\n    //initialize style sheets related variables\n    this.styleSheets = null;\n    this.cssFileName = \"style.css\"; //change this to get css file name from config in future\n    this.styleSheet = null;\n    this.rules = null;\n    this.effectiveRules = null;\n    // this.rulesWithPseudo = null;\n\n    this.defaultCssFileName = \"apertaDefault.css\";\n    this.defaultStyleSheet = null;\n    this.defaultRules = null;\n    this.effectiveDefaultRules = null;\n\n    //\n    this.selectorList = {};\n    this.pseudoList = {};\n\n    //get css style from style sheet\n    //\n    this.styleSheets = this.canvasDocument.styleSheets;\n    // console.log(this.styleSheets);\n    for (var i = 0; i < this.styleSheets.length; i++) {\n      if (this.styleSheets[i].href.endsWith(this.defaultCssFileName)) {\n        this.defaultStyleSheet = this.styleSheets[i];\n        this.defaultRules = this.defaultStyleSheet.cssRules || this.defaultStyleSheet.rules;\n\n        //get effective css rules from default css file\n        this.effectiveDefaultRules = this.getEffectiveRules(this.defaultRules);\n\n        // console.log(this.defaultStyleSheet);\n      }\n\n      if (this.styleSheets[i].href.endsWith(this.cssFileName)) {\n        this.styleSheet = this.styleSheets[i];\n        this.rules = this.styleSheet.cssRules || this.styleSheet.rules;\n\n        //get effective css rules from user defined css file\n        this.effectiveRules = this.getEffectiveRules(this.rules);\n      }\n    }\n  }\n\n  // return applied css style of propety, selector and if !important is set\n  _createClass(CssStyleManager, [{\n    key: \"getAppliedRule\",\n    value: function getAppliedRule(propertyName) {\n      var objectKeys = null;\n      var isAppliedImportant = false;\n      var appliedSpecificity = 0;\n      var appliedPropertyValue = null;\n      var appliedSelector = null;\n      var appliedColor = null;\n      var appliedRule = null;\n\n      // check element inline style and set value if it has property value\n      // \n      var propertyValue = this.selectedElm.style[propertyName];\n      if (propertyValue !== \"\") {\n        var isImportant = this.isImportant(this.selectedElm.style, propertyName);\n        appliedSelector = \"inline\";\n        appliedColor = \"#0000FF\";\n        appliedPropertyValue = propertyValue;\n        isAppliedImportant = isImportant;\n        appliedRule = this.selectedElm.style;\n      }\n      // console.log(\"Selector:  \" + appliedSelector + \"  propertyName:  \" + propertyName + \":  propertyValue:  \" + appliedPropertyValue + \"  isAppliedImportant:  \" + isAppliedImportant);\n      // console.log(this.selectedElm.style);\n\n      // check css style and get property with highest priority (considering specificity and !important)\n      //\n\n      // consider to change this part of code to support multiple css files in the future\n      objectKeys = Object.keys(this.effectiveRules);\n      if (appliedPropertyValue === null) {\n        // for (let i = objectKeys.length / 2 - 1; i >= 0; i--) {\n        for (var i = 0; i < objectKeys.length / 2; i++) {\n          var stringKey = this.effectiveRules[i];\n          var selectorText = this.effectiveRules[stringKey].selectorText;\n          var selectorToMatch = this.effectiveRules[stringKey].selectorToMatch;\n\n          //ignore if ObjectKeys and selectorToMatch are not the same (ignore selector with pseudo elements and classes)\n          if (selectorText === selectorToMatch) {\n            // console.log(this.effectiveRules[objectKeys[i]]);\n            var _propertyValue = this.effectiveRules[stringKey].style[propertyName];\n\n            // if propertyValue is not empty, check if !important is set\n            if (_propertyValue !== \"\") {\n              var propertySpecificity = this.effectiveRules[stringKey].specificity;\n              var _isImportant = this.isImportant(this.effectiveRules[stringKey].style, propertyName);\n              var selectorColor = this.effectiveRules[stringKey].color;\n\n              // when both rules have !important, check which rule has higher specificity\n              if (_isImportant && isAppliedImportant) {\n                if (appliedSpecificity <= propertySpecificity) {\n                  appliedSelector = selectorText;\n                  appliedColor = selectorColor;\n                  appliedPropertyValue = _propertyValue;\n                  isAppliedImportant = _isImportant;\n                  appliedSpecificity = propertySpecificity;\n                  appliedRule = this.effectiveRules[stringKey];\n                }\n              }\n              //if previous rule does not have !important, and current rule has !important, set the current rule as applied rule\n              else if (_isImportant && !isAppliedImportant) {\n                appliedSelector = selectorText;\n                appliedColor = selectorColor;\n                appliedPropertyValue = _propertyValue;\n                isAppliedImportant = _isImportant;\n                appliedSpecificity = propertySpecificity;\n                appliedRule = this.effectiveRules[stringKey];\n              }\n              // if both rules do not have !important, check which rule has higher specificity\n              else if (!_isImportant && !isAppliedImportant) {\n                if (appliedSpecificity <= propertySpecificity) {\n                  appliedSelector = selectorText;\n                  appliedColor = selectorColor;\n                  appliedPropertyValue = _propertyValue;\n                  isAppliedImportant = _isImportant;\n                  appliedSpecificity = propertySpecificity;\n                  appliedRule = this.effectiveRules[stringKey];\n                }\n              }\n              // if previous rule has !important, ignore the new rule\n            }\n          }\n        }\n      }\n      // console.log(\"Selector:  \" + appliedSelector + \"  propertyName:  \" + propertyName + \":  propertyValue:  \" + appliedPropertyValue + \"  isAppliedImportant:  \" + isAppliedImportant);\n\n      // check default css rule if no element style and css rule to apply\n      //\n\n      if (appliedPropertyValue === null) {\n        objectKeys = Object.keys(this.effectiveDefaultRules);\n        // console.log(objectKeys);\n        // for (let i = objectKeys.length / 2 - 1; i >= 0; i--) {\n        for (var _i = 0; _i < objectKeys.length / 2; _i++) {\n          var _stringKey = this.effectiveDefaultRules[_i];\n          var _selectorText = this.effectiveDefaultRules[_stringKey].selectorText;\n          var _propertyValue2 = this.effectiveDefaultRules[_stringKey].style[propertyName];\n          if (_propertyValue2 !== \"\") {\n            var _propertySpecificity = this.effectiveDefaultRules[_stringKey].specificity;\n            var _isImportant2 = this.isImportant(this.effectiveDefaultRules[_stringKey].style, propertyName);\n            // console.log(objectKeys[i] + \":  \" + propertyName + \":  \" + propertyValue + \" isImportant: \" + isImportant);\n            if (appliedSpecificity <= _propertySpecificity) {\n              appliedSelector = _selectorText;\n              appliedPropertyValue = _propertyValue2;\n              isAppliedImportant = _isImportant2;\n              appliedSpecificity = _propertySpecificity;\n              appliedRule = this.effectiveDefaultRules[_stringKey];\n            }\n          }\n          // const propertyValue = this.effectiveDefaultRules[propertyName];\n          // console.log(this.effectiveDefaultRules);\n        }\n      }\n\n      //\n      // TODO: Add feature to check if the property is inherited in the future\n      //\n      //\n\n      return {\n        appliedSelector: appliedSelector,\n        appliedPropertyValue: appliedPropertyValue,\n        isAppliedImportant: isAppliedImportant,\n        appliedColor: appliedColor\n      };\n    }\n  }, {\n    key: \"getRuleBySelectorAndPropertyName\",\n    value: function getRuleBySelectorAndPropertyName(selector, propertyName) {\n      var isImportant = false;\n      var propertyValue = null;\n      // let selector = null;\n      var color = null;\n      // let Rule = null;\n\n      if (selector === \"inline\") {\n        // console.log(\"inline\");\n        propertyValue = this.selectedElm.style[propertyName];\n        if (propertyValue !== \"\") {\n          isImportant = this.isImportant(this.selectedElm.style, propertyName);\n\n          // selector = \"inline\";\n          color = \"#0000FF\";\n          // propertyValue = propertyValue;\n          // isImportant = isImportant;\n          // Rule = this.selectedElm.style;\n        }\n      } else {\n        propertyValue = this.effectiveRules[selector].style[propertyName];\n        if (propertyValue !== \"\") {\n          color = this.effectiveRules[selector].color;\n          // selector = this.effectiveRules[selector].selectorText;\n          isImportant = this.isImportant(this.effectiveRules[selector].style, propertyName);\n\n          // console.log(this.effectiveRules[selector]);\n        }\n      }\n\n      // console.log(\"Selector: \" + selector + \"  propertyName: \" + propertyName + \"  PropertyValue: \" + propertyValue + \"  isImportant: \" + isImportant);\n      return {\n        propertyName: propertyName,\n        propertyValue: propertyValue,\n        isImportant: isImportant,\n        color: color\n      };\n    }\n  }, {\n    key: \"getEffectiveRules\",\n    value: function getEffectiveRules(rules) {\n      // console.log(this.defaultRules);\n      // console.log(this.rules);\n      // let includePseudo = null;\n      var effectiveRules = {};\n      var numberOfRules = 0;\n      this.selectorList = {\n        0: \"inline\",\n        \"inline\": {\n          color: \"#0000FF\"\n        }\n      };\n      this.pseudoList = {};\n      var selectorIndex = 1;\n      var pseudoIndex = 0;\n      for (var j = 0; j < rules.length; j++) {\n        // set selectorText without pseudo element and class\n        rules[j].selectorToMatch = this.removePseudo(rules[j].selectorText);\n        if (this.selectedElm.matches(rules[j].selectorToMatch)) {\n          // add speficity to rules to find property with the highest priority\n          rules[j].specificity = this.getSpecificity(rules[j].selectorText);\n\n          // add color to rules to use in the cssEditor\n          rules[j].color = this.getTagColor(numberOfRules);\n          if (rules[j].selectorText === rules[j].selectorToMatch) {\n            this.selectorList[selectorIndex] = rules[j].selectorText;\n            this.selectorList[rules[j].selectorText] = {\n              color: rules[j].color\n            };\n            selectorIndex++;\n          } else {\n            this.pseudoList[pseudoIndex] = rules[j].selectorText;\n            this.pseudoList[rules[j].selectorText] = {\n              color: rules[j].color\n            };\n            pseudoIndex++;\n          }\n          effectiveRules[numberOfRules] = rules[j].selectorText;\n          effectiveRules[rules[j].selectorText] = rules[j];\n          numberOfRules++;\n        }\n      }\n      return effectiveRules;\n    }\n  }, {\n    key: \"getSelectorList\",\n    value: function getSelectorList() {\n      return this.selectorList;\n    }\n  }, {\n    key: \"getPseudoList\",\n    value: function getPseudoList() {\n      return this.pseudoList;\n    }\n  }, {\n    key: \"getTagColor\",\n    value: function getTagColor(i) {\n      var tagColors = [\"#FFA500\", \"#FF0000\", \"#008000\", \"#FFFF00\", \"#800080\", \"#00FFFF\", \"#FF00FF\"];\n      if (i < tagColors.length) {\n        return tagColors[i];\n      } else {\n        return generateRandomColor();\n      }\n    }\n\n    // get specificity of a selector\n  }, {\n    key: \"getSpecificity\",\n    value: function getSpecificity(selectorText) {\n      var result = (0,specificity__WEBPACK_IMPORTED_MODULE_1__.calculate)(selectorText);\n      // console.log(result);\n      var specificityArray = result[0].specificityArray;\n      var specificityValue = specificityArray[0] * 1000 + specificityArray[1] * 100 + specificityArray[2] * 10 + specificityArray[3];\n      return specificityValue;\n    }\n\n    // setter\n    // \n  }, {\n    key: \"setRule\",\n    value: function setRule(selector, propertyName, cssValue) {\n      if (selector === \"inline\") {\n        this.selectedElm.style[propertyName] = cssValue;\n      } else {\n        for (var i = 0; i < this.rules.length; i++) {\n          var rule = this.rules[i];\n          if (rule.selectorText === selector) {\n            rule.style[propertyName] = cssValue;\n            this.styleSheet.deleteRule(i);\n            this.styleSheet.insertRule(rule.cssText, i);\n          }\n        }\n      }\n      // update caption of selected element to apply the change\n      Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../utils.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())(this.selectedElm);\n      // update effectiveRules\n      this.effectiveRules = this.getEffectiveRules(this.rules);\n    }\n\n    // bool functions \n    //\n  }, {\n    key: \"isImportant\",\n    value: function isImportant(cssStyle, propertyName) {\n      var priority = cssStyle.getPropertyPriority(propertyName);\n      return priority === 'important';\n    }\n\n    // utility functions\n    //\n  }, {\n    key: \"removePseudo\",\n    value: function removePseudo(selectorText) {\n      var pseudoElementRegex = /::(before|after|first-letter|first-line|selection|backdrop|placeholder|marker|spelling-error|grammar-error)/i;\n      var pseudoClassRegex = /:(?:(?:active|hover|focus|visited|link|enabled|disabled|checked|indeterminate|valid|invalid|required|optional|read-only|read-write|first-child|last-child|nth-child|nth-last-child|first-of-type|last-of-type|nth-of-type|nth-last-of-type|only-child|only-of-type|target|root|empty|not|lang|dir|is|where|has|scope|fullscreen|current|past|future)(?:\\(.*?\\))?)/gi;\n      // const pseudoClassRegex = /:(active|hover|focus|visited|link|enabled|disabled|checked|indeterminate|valid|invalid|required|optional|read-only|read-write|first-child|last-child|nth-child|nth-last-child|first-of-type|last-of-type|nth-of-type|nth-last-of-type|only-child|only-of-type|target|root|empty|not|lang|dir|is|where|has|scope|fullscreen|current|past|future)/i;\n\n      var cleanedSelector = selectorText.replace(pseudoElementRegex, '').replace(pseudoClassRegex, '');\n      return cleanedSelector.trim();\n    }\n  }, {\n    key: \"hslToRgb\",\n    value: function hslToRgb(h, s, l) {\n      var r, g, b;\n      if (s === 0) {\n        r = g = b = l; // achromatic\n      } else {\n        var hue2rgb = function hue2rgb(p, q, t) {\n          if (t < 0) t += 1;\n          if (t > 1) t -= 1;\n          if (t < 1 / 6) return p + (q - p) * 6 * t;\n          if (t < 1 / 2) return q;\n          if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n          return p;\n        };\n        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n        var p = 2 * l - q;\n        r = hue2rgb(p, q, h + 1 / 3);\n        g = hue2rgb(p, q, h);\n        b = hue2rgb(p, q, h - 1 / 3);\n      }\n      return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];\n    }\n  }, {\n    key: \"generateRandomColor\",\n    value: function generateRandomColor() {\n      // hue (0-360)\n      var hue = Math.random();\n\n      // saturation (30-100)\n      var saturation = Math.random() * (100 - 30 + 1) + 30;\n\n      // lightness (30-70)\n      var lightness = Math.random() * (70 - 30 + 1) + 30;\n      var _hslToRgb = hslToRgb(hue, saturation / 100, lightness / 100),\n        _hslToRgb2 = _slicedToArray(_hslToRgb, 3),\n        r = _hslToRgb2[0],\n        g = _hslToRgb2[1],\n        b = _hslToRgb2[2];\n      return \"#\".concat(r.toString(16).padStart(2, '0')).concat(g.toString(16).padStart(2, '0')).concat(b.toString(16).padStart(2, '0'));\n    }\n  }]);\n  return CssStyleManager;\n}();\n\n//# sourceURL=webpack://aperta/./views/webdesign/Utils/CssStyleManager.js?");

/***/ }),

/***/ "./views/webdesign/Utils/ElementEventListeners.js":
/*!********************************************************!*\
  !*** ./views/webdesign/Utils/ElementEventListeners.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"addClickEventListeners\": () => (/* binding */ addClickEventListeners),\n/* harmony export */   \"addDblClickEventListeners\": () => (/* binding */ addDblClickEventListeners),\n/* harmony export */   \"addDragAndDropEventListeners\": () => (/* binding */ addDragAndDropEventListeners),\n/* harmony export */   \"addHoverEventListeners\": () => (/* binding */ addHoverEventListeners),\n/* harmony export */   \"addKeydownEventListeners\": () => (/* binding */ addKeydownEventListeners)\n/* harmony export */ });\n/* harmony import */ var _ElementManager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ElementManager.js */ \"./views/webdesign/Utils/ElementManager.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"./views/webdesign/Utils/utils.js\");\n\n// import { setCssValueToCssEditor } from \"./CssEditorUtils.js\";\n\n\n\n\n\n\n// import { checkIfElementIsSelected } from \"./RightSideMenuTabs.svelte\";\n\n/* \n    *  Keydown event listeners\n*/\n\nfunction addKeydownEventListeners(elm) {\n  elm.addEventListener('keydown', function (event) {\n    // const canvas = document.getElementById(\"canvas\");\n    // const canvasWindow = canvas.contentWindow;\n    // const canvasDocument = canvasWindow.document;\n    // const selectedElement = canvasDocument.getElementById(\"selectedElm\");\n\n    var canvasWrapper = new _utils_js__WEBPACK_IMPORTED_MODULE_1__.CanvasWrapper();\n    var selectedElm = canvasWrapper.getSelectedElement();\n\n    //delete element when delete or backspace key is pressed\n    if (event.keyCode === 46 || event.keyCode === 8) {\n      //delete selected element except for a body element\n\n      if (selectedElm.tagName !== \"BODY\" && selectedElm.hasAttribute(\"contenteditable\") === false) {\n        if (selectedElm.previousElementSibling !== null) {\n          (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.selectElm)(selectedElm.previousElementSibling);\n          (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.addCaptionToSelectedElm)(selectedElm.previousElementSibling);\n        } else if (selectedElm.parentElement !== null) {\n          (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.selectElm)(selectedElm.parentElement);\n          (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.addCaptionToSelectedElm)(selectedElm.parentElement);\n        }\n        selectedElm.remove();\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.adjustBodyHeight)();\n      }\n    }\n    //make contenteditable false when meta + enter key is pressed\n    if (event.metaKey && event.key === \"Enter\") {\n      //if contentedible is true, make it false\n\n      if (selectedElm.tagName !== \"BODY\" && selectedElm.hasAttribute(\"contenteditable\") === true) {\n        selectedElm.removeAttribute(\"contenteditable\");\n        selectedElm.removeAttribute(\"spellcheck\");\n      }\n    }\n    if (event.key === \"ArrowUp\") {\n      //change selected element to previous sibling element or parent element\n      event.preventDefault();\n      if (selectedElm.tagName === \"BODY\") return;\n      if (selectedElm.previousElementSibling !== null) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.selectElm)(selectedElm.previousElementSibling);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.addCaptionToSelectedElm)(selectedElm.previousElementSibling);\n      } else if (selectedElm.parentElement !== null) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.selectElm)(selectedElm.parentElement);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.addCaptionToSelectedElm)(selectedElm.parentElement);\n      }\n    }\n    if (event.key === \"ArrowDown\") {\n      //change selected element to next sibling element or first child element\n      event.preventDefault();\n      if (selectedElm.tagName == \"BODY\") {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.selectElm)(selectedElm.firstElementChild);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.addCaptionToSelectedElm)(selectedElm.firstElementChild);\n        return;\n      }\n      if (selectedElm.nextElementSibling !== null) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.selectElm)(selectedElm.nextElementSibling);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.addCaptionToSelectedElm)(selectedElm.nextElementSibling);\n      } else if (selectedElm.firstElementChild !== null) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.selectElm)(selectedElm.firstElementChild);\n      }\n    }\n    if (event.key === \"ArrowLeft\") {}\n  }, true);\n}\n\n/* \n    *  Hover event listeners\n*/\n\nfunction addHoverEventListeners(elm) {\n  //Hover activate: add hover class to hovered element to highlight\n  //\n  elm.addEventListener(\"mouseover\", function (event) {\n    event.preventDefault();\n    var canvasWrapper = new _utils_js__WEBPACK_IMPORTED_MODULE_1__.CanvasWrapper();\n    var ignoreId = [\"marginLine\", \"paddingLine\"];\n\n    // return if the target element is selected\n    // if (event.target.id === (\"selectedElm\") || ignoreId.includes(event.target.id)) {\n    if (event.target.hasAttribute(canvasWrapper.getSelectedElementAttributeName()) || ignoreId.includes(event.target.id)) {\n      return;\n    }\n\n    // add caption to hovered element\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.addCaptionToHoveredElm)(event.target);\n    event.stopPropagation();\n  }, false);\n\n  //Hover deactivate: remove hover class to hovered element to highlight\n  //\n  elm.addEventListener(\"mouseout\", function (event) {\n    event.preventDefault();\n\n    // delete old hovered element before creating a new one\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.delCaptionFromHoveredElm)(event.target);\n    event.stopPropagation();\n  }, false);\n}\n\n/* \n    Click event listeners\n*/\n\nfunction addClickEventListeners(elm) {\n  //Click: set clicked element as a selected elemment\n  //\n  elm.addEventListener(\"click\", function (event) {\n    var ignoreId = [\"marginLine\", \"paddingLine\"];\n\n    // return if the target element id is included in ignoreId\n    if (ignoreId.includes(event.target.id)) {\n      return;\n    }\n\n    // delete contenteditable attribute from a current selected element\n    var canvasDocument = elm.ownerDocument;\n    var targetElements = canvasDocument.querySelector('[contenteditable=\"true\"]');\n    if (targetElements !== null) {\n      if (elm.getAttribute('data-aperta-uuid') !== targetElements.getAttribute('data-aperta-uuid')) {\n        targetElements.removeAttribute(\"contenteditable\");\n        targetElements.removeAttribute(\"spellcheck\");\n      }\n    }\n\n    //delete hover class from a current hovered element\n    var hoverCaption = event.target.ownerDocument.getElementById(\"hoverCaption\");\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.delCaptionFromHoveredElm)(hoverCaption);\n\n    // set id to selected element\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.selectElm)(event.target);\n\n    // add caption to selected element\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.addCaptionToSelectedElm)(event.target);\n\n    // TODO: add listeners to change size, margin, padding of selected element\n    //\n    // addListenersToChangeSizeMarginPadding(canvasDocument, rect);\n\n    event.stopPropagation();\n  }, false);\n}\n\n// currently not in use\n// TODO: add listeners to change size, margin, padding of selected element\n//\nfunction addListenersToChangeSizeMarginPadding() {\n  // const canvas = document.getElementById(\"canvas\");\n  // const canvasWindow = canvas.contentWindow;\n  // const canvasDocument = canvasWindow.document;\n  var canvasWrapper = new _utils_js__WEBPACK_IMPORTED_MODULE_1__.CanvasWrapper();\n  var canvasDocument = canvasWrapper.getCanvasDocument();\n  var cursorIsOn = \"notInArea\";\n\n  //track if the margin or padding has changed\n  var marginChanged = true;\n  var paddingChanged = true;\n  canvasDocument.addEventListener(\"mousemove\", function (event) {\n    //get the selected element to get its position\n    var selectedElm = canvasWrapper().getSelectedElm();\n    //return if selected elm is body\n    if (selectedElm.tagName === \"BODY\") {\n      return;\n    }\n    var rect = selectedElm.getBoundingClientRect();\n    var rectTop = Math.round(rect.top);\n    var rectBottom = Math.round(rect.bottom);\n    var rectLeft = Math.round(rect.left);\n    var rectRight = Math.round(rect.right);\n    var incrementIfZero = function incrementIfZero(value) {\n      return value === 0 ? 1 : value;\n    };\n\n    //get the margin and padding of the selected element\n    var marginTop = parseInt(window.getComputedStyle(selectedElm).marginTop);\n    var marginRight = parseInt(window.getComputedStyle(selectedElm).marginRight);\n    var marginBottom = parseInt(window.getComputedStyle(selectedElm).marginBottom);\n    var marginLeft = parseInt(window.getComputedStyle(selectedElm).marginLeft);\n\n    //if margin is 0, set it to 1 to show the line\n    var marginLineTop = incrementIfZero(marginTop);\n    var marginLineRight = incrementIfZero(marginRight);\n    var marginLineBottom = incrementIfZero(marginBottom);\n    var marginLineLeft = incrementIfZero(marginLeft);\n    var paddingTop = parseInt(window.getComputedStyle(selectedElm).paddingTop);\n    var paddingRight = parseInt(window.getComputedStyle(selectedElm).paddingRight);\n    var paddingBottom = parseInt(window.getComputedStyle(selectedElm).paddingBottom);\n    var paddingLeft = parseInt(window.getComputedStyle(selectedElm).paddingLeft);\n\n    //if padding is 0, set it to 1 to show the line\n    var paddingLineTop = incrementIfZero(paddingTop);\n    var paddingLineRight = incrementIfZero(paddingRight);\n    var paddingLineBottom = incrementIfZero(paddingBottom);\n    var paddingLineLeft = incrementIfZero(paddingLeft);\n\n    //only create new margin line if the margin has changed\n    if (marginChanged === true) {\n      //delete previous margin and padding line\n      var marginLine = canvasDocument.getElementById(\"marginLine\");\n      if (marginLine !== null) {\n        marginLine.remove();\n      }\n      // add new margin line\n      //add div to show line of margin\n      marginLine = document.createElement(\"div\");\n      marginLine.id = \"marginLine\";\n      marginLine.style.position = \"absolute\";\n      // marginLine.style.backgroundColor = \"red\";\n      marginLine.style.height = rectBottom - rectTop + marginLineTop + marginLineBottom + \"px\";\n      marginLine.style.width = rectRight - rectLeft + marginLineRight + marginLineLeft + \"px\";\n      marginLine.style.top = rectTop - marginLineTop + \"px\";\n      marginLine.style.left = rectLeft - marginLineLeft + \"px\";\n      marginLine.style.border = \"1px dashed #1bbcf1\";\n      marginLine.style.zIndex = \"9\";\n      console.log(\"rectLeft: \" + rectLeft + \"marginLineLeft: \" + marginLineLeft + \"rectRight: \" + rectRight + \"marginLineRight: \" + marginLineRight + \"rectTop: \" + rectTop + \"marginLineTop: \" + marginLineTop + \"rectBottom: \" + rectBottom + \"marginLineBottom: \" + marginLineBottom + \"\");\n      event.target.before(marginLine);\n      marginChanged = false;\n    }\n\n    //only create new padding line if the padding has changed\n    if (paddingChanged === true) {\n      //delete previous margin and padding line\n      var paddingLine = canvasDocument.getElementById(\"paddingLine\");\n      if (paddingLine !== null) {\n        paddingLine.remove();\n      }\n\n      //add div to show line of padding\n      paddingLine = document.createElement(\"div\");\n      paddingLine.id = \"paddingLine\";\n      paddingLine.style.position = \"absolute\";\n      // paddingLine.style.backgroundColor = \"red\";\n      paddingLine.style.height = rectBottom - rectTop - paddingLineTop * 2 - paddingLineBottom + \"px\";\n      paddingLine.style.width = rectRight - rectLeft - paddingLineRight - paddingLineLeft * 2 + \"px\";\n      paddingLine.style.top = rectTop + paddingLineTop + \"px\";\n      paddingLine.style.left = rectLeft + paddingLineLeft + \"px\";\n      paddingLine.style.border = \"1px dashed #1bbcf1\";\n      paddingLine.style.zIndex = \"9\";\n      event.target.before(paddingLine);\n      paddingChanged = false;\n    }\n\n    //add div to show line of padding\n\n    //check marign and padding of the selected element\n    // console.log(\"margin: \" + marginTop + \" \" + marginRight + \" \" + marginBottom + \" \" + marginLeft);\n    // console.log(\"padding: \" + paddingTop + \" \" + paddingRight + \" \" + paddingBottom + \" \" + paddingLeft);\n\n    // console.log(\"margin: \" + marginTop + \" \" + marginRight + \" \" + marginBottom + \" \" + marginLeft);\n    // console.log(\"padding: \" + paddingTop + \" \" + paddingRight + \" \" + paddingBottom + \" \" + paddingLeft);\n\n    //check if the cursor is on the top left edge of the selected element\n    // if (event.clientX === rectLeft && event.clientY === rectTop) {\n    //     console.log(\"elm: top left\");\n    // } else if (event.clientX === rectRight && event.clientY === rectTop) {\n    //     console.log(\"elm: top right\");\n    // } else if (event.clientX === rectLeft && event.clientY === rectBottom) {\n    //     console.log(\"elm: bottom left\");\n    // } else if (event.clientX === rectRight && event.clientY === rectBottom) {\n    //     console.log(\"elm: bottom right\");\n    // } else if (event.clientX > rectLeft && event.clientX < rectRight && event.clientY === rectTop) {\n    //     console.log(\"elm: top\");\n    // } else if (event.clientX > rectLeft && event.clientX < rectRight && event.clientY === rectBottom) {\n    //     console.log(\"elm: bottom\");\n    // } else if (event.clientX === rectLeft && event.clientY > rectTop && event.clientY < rectBottom) {\n    //     console.log(\"elm: left\");\n    // } else if (event.clientX === rectRight && event.clientY > rectTop && event.clientY < rectBottom) {\n    //     console.log(\"elm: right\");\n    // }\n    // //check if the cursor is on the top left edge of the selected elemnt's margin\n    // else if (event.clientX === rectLeft - marginLineLeft && event.clientY === rectTop - marginLineTop) {\n    //     console.log(\"margin: top left\");\n    // } else if (event.clientX === rectRight + marginLineRight && event.clientY === rectTop - marginLineTop) {\n    //     console.log(\"margin: top right\");\n    // } else if (event.clientX === rectLeft - marginLineLeft && event.clientY === rectBottom + marginLineBottom) {\n    //     console.log(\"margin: bottom left\");\n    // } else if (event.clientX === rectRight + marginLineRight && event.clientY === rectBottom + marginLineBottom) {\n    //     console.log(\"margin: bottom right\");\n    // } else if (event.clientX > rectLeft - marginLineLeft && event.clientX < rectRight + marginLineRight && event.clientY === rectTop - marginLineTop) {\n    //     console.log(\"margin: top\");\n    // } else if (event.clientX > rectLeft - marginLineLeft && event.clientX < rectRight + marginLineRight && event.clientY === rectBottom + marginLineBottom) {\n    //     console.log(\"margin: bottom\");\n    // } else if (event.clientX === rectLeft - marginLineLeft && event.clientY > rectTop - marginLineTop && event.clientY < rectBottom + marginLineBottom) {\n    //     console.log(\"margin: left\");\n    // } else if (event.clientX === rectRight + marginLineRight && event.clientY > rectTop - marginLineTop && event.clientY < rectBottom + marginLineBottom) {\n    //     console.log(\"margin: right\");\n    // }\n    // //check if the cursor is on the top left edge of the selected elemnt's padding\n    // else if (event.clientX === rectLeft + marginLeft && event.clientY === rectTop + marginTop) {\n    //     console.log(\"padding: top left\");\n    // } else if (event.clientX === rectRight - marginRight && event.clientY === rectTop + marginTop) {\n    //     console.log(\"padding: top right\");\n    // } else if (event.clientX === rectLeft + marginLeft && event.clientY === rectBottom - marginBottom) {\n    //     console.log(\"padding: bottom left\");\n    // } else if (event.clientX === rectRight - marginRight && event.clientY === rectBottom - marginBottom) {\n\n    //     console.log(\"padding: bottom right\");\n    // } else if (event.clientX > rectLeft + marginLeft && event.clientX < rectRight - marginRight && event.clientY === rectTop + marginTop) {\n    //     console.log(\"padding: top\");\n    // } else if (event.clientX > rectLeft + marginLeft && event.clientX < rectRight - marginRight && event.clientY === rectBottom - marginBottom) {\n    //     console.log(\"padding: bottom\");\n    // } else if (event.clientX === rectLeft + marginLeft && event.clientY > rectTop + marginTop && event.clientY < rectBottom - marginBottom) {\n    //     console.log(\"padding: left\");\n    // } else if (event.clientX === rectRight - marginRight && event.clientY > rectTop + marginTop && event.clientY < rectBottom - marginBottom) {\n    //     console.log(\"padding: right\");\n    // } else {\n    //     console.log(\"notInArea\");\n    // }\n\n    // check if the mouse is inside the selected element\n    // if (event.clientX > rect.left && event.clientX < rect.right && event.clientY > rect.top && event.clientY < rect.bottom) {\n    //     console.log(\"inside\");\n    // } else {\n    //     console.log(\"not inside\");\n    // }\n\n    // if (event.clientX > rect.left && event.clientX < rect.right && event.clientY > rect.top && event.clientY < rect.bottom) {\n    //     console.log(\"HERE!!\");\n    // } else {\n    //     console.log(\"NOT HERE!!\");\n    // }\n\n    // console.log(\" rect.top: \" + rectTop + \" event.clientY: \" + event.clientY);\n    // console.log(\"event.clientX: \" + event.clientX + \"event.clientY: \" + event.clientY);\n    // console.log(\" rect.left: \" + rect.left + \" rect.top: \" + rect.top);\n    // console.log(\"clientX: \" + event.clientX + \" clientY: \" + event.clientY);\n  });\n  // add keydown event listener to\n}\n\n/* \n    *  Double click event listener\n*/\n\n// Double Click: make element editable when double clicked\n//\nfunction addDblClickEventListeners(elm) {\n  elm.addEventListener(\"dblclick\", function () {\n    // add contenteditable attributes to a double clicked element\n    if (elm.tagName !== \"BODY\") {\n      elm.setAttribute(\"contenteditable\", \"true\");\n      elm.setAttribute(\"spellcheck\", \"true\");\n    }\n  }, false);\n}\n\n/* \n    *  Drag and Drop event listeners\n*/\n\n//use to set data to identify which element to swap when drop event is fired\nvar draggedElm = null;\n//use in dragover event to identify when to insert element before or after, and, to prevent swapping with itself\nvar previousState = null;\n// \nvar draggedOverOutline = null;\nfunction addDragAndDropEventListeners(elm) {\n  //Dragging: enable drag and drop element swapping\n  elm.addEventListener('dragstart', function (event) {\n    //set transparent image to prevent to show a default drag image\n    var transparentImage = new Image();\n    transparentImage.src = \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\";\n    event.dataTransfer.setDragImage(transparentImage, 0, 0);\n\n    //set drag effect to move (to delete + icon while drag & drop)\n    event.dataTransfer.effectAllowed = \"move\";\n\n    //Set data to identify which element to swap when drop event is fired\n    draggedElm = event.target;\n\n    // const canvasWrapper = new CanvasWrapper();\n    // console.log(canvasWrapper.isSelectedElement(draggedElm));\n\n    //change state of draggedElm to selectedElm if draggedElm is not selectedElm\n    var canvasWrapper = new _utils_js__WEBPACK_IMPORTED_MODULE_1__.CanvasWrapper();\n    if (!canvasWrapper.isSelectedElement(draggedElm)) {\n      // if (draggedElm.id !== \"selectedElm\") {\n      // set id to selected element\n      (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.selectElm)(event.target);\n\n      // add caption to selected element\n      (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.addCaptionToSelectedElm)(event.target);\n    }\n  });\n\n  //Dragover: identify when to insert element before or after, and, to prevent swapping with itself\n  elm.addEventListener('dragover', function (event) {\n    event.preventDefault();\n    // get canvas window and document\n    var canvasWindow = event.target.ownerDocument.defaultView;\n    var canvasDocument = event.target.ownerDocument;\n\n    //get elementManager and check if draggedElm can be parent of event.target\n    var element = (0,_ElementManager_js__WEBPACK_IMPORTED_MODULE_0__.elementManagerFactory)(event.target.tagName);\n    var canBeParentOf = element.canBeParentOf(draggedElm);\n    // console.log(\"can be parent of:\" + canBeParentOf);\n\n    //\n    if (event.target.getAttribute(\"data-aperta-uuid\") === draggedElm.getAttribute(\"data-aperta-uuid\")) {\n      //console.log(\"same element\");\n      return;\n    }\n\n    //\n    var rect = event.target.getBoundingClientRect();\n    var offset = event.clientY - rect.top;\n\n    //create outline div for element to show user where element will be inserted\n    if (draggedOverOutline === null) {\n      draggedOverOutline = document.createElement(\"div\");\n      draggedOverOutline.id = \"draggedOverOutline\";\n      draggedOverOutline.classList = \"draggedOverOutline\";\n      var absoluteRectTop = rect.top + canvasWindow.scrollY;\n      var absoluteRectBottom = rect.bottom + canvasWindow.scrollY;\n      var absoluteRectLeft = rect.left + canvasWindow.scrollX;\n      var absoluteRectRight = rect.right + canvasWindow.scrollX;\n      draggedOverOutline.style.left = absoluteRectLeft + \"px\";\n      draggedOverOutline.style.top = absoluteRectTop + \"px\";\n      draggedOverOutline.style.width = absoluteRectRight - absoluteRectLeft + \"px\";\n      draggedOverOutline.style.height = absoluteRectBottom - absoluteRectTop + \"px\";\n\n      //add outline div after document's last element\n      canvasDocument.body.after(draggedOverOutline);\n    }\n\n    // console.log(canvasDocument.lastElementChild);\n\n    //allow user to insert an element as a child\n    if (canBeParentOf) {\n      //add class to element to show user where element will be inserted\n      //assign true to isInTo if offset is in top 1/3 of element\n      var isAtTop = offset < rect.height / 3;\n      //return true if offset is in bottom 1/3 of element\n      var isAtBottom = offset > rect.height * 2 / 3;\n\n      //console.log(\"top: \" + isAtTop + \" bottom: \" + isAtBottom);\n\n      //add class to element to show user where element will be inserted\n      if (isAtTop) {\n        //change class only if previous state is not isAtTop\n        if (previousState !== \"isAtTop\") {\n          //remove previous class if other part of element is highlighted\n          if (previousState !== null) {\n            draggedOverOutline.classList.remove(previousState);\n          }\n          //set previous state to isAtTop\n          previousState = \"isAtTop\";\n          //add isAtTop class to element to highlight where element will be inserted\n          draggedOverOutline.classList.add(\"isAtTop\");\n        }\n        // console.log(\"isAtTop\");\n      } else if (isAtBottom) {\n        if (previousState !== \"isAtBottom\") {\n          if (previousState !== null) {\n            draggedOverOutline.classList.remove(previousState);\n          }\n          previousState = \"isAtBottom\";\n          draggedOverOutline.classList.add(\"isAtBottom\");\n        }\n        // console.log(\"isAtBottom\");\n      } else if (!isAtTop && !isAtBottom) {\n        if (previousState !== \"middle\") {\n          if (previousState !== null) {\n            draggedOverOutline.classList.remove(previousState);\n          }\n          previousState = \"middle\";\n          draggedOverOutline.classList.add(\"middle\");\n        }\n        // console.log(\"middle\");\n      }\n    }\n    //only allow user to insert an element as a sibling\n    else {\n      //assign true to isInTo if offset is in top 1/3 of element\n      var _isAtTop = offset < rect.height / 2;\n\n      //console.log(\"top: \" + isAtTop + \" bottom: \" + isAtBottom);\n\n      //add class to element to show user where element will be inserted\n      if (_isAtTop) {\n        //change class only if previous state is not isAtTop\n        if (previousState !== \"isAtTop\") {\n          //remove previous class if other part of element is highlighted\n          if (previousState !== null) {\n            draggedOverOutline.classList.remove(previousState);\n          }\n          //set previous state to isAtTop\n          previousState = \"isAtTop\";\n          //add isAtTop class to element to highlight where element will be inserted\n          draggedOverOutline.classList.add(\"isAtTop\");\n        }\n        // console.log(\"isAtTop\");\n      } else {\n        if (previousState !== \"isAtBottom\") {\n          if (previousState !== null) {\n            draggedOverOutline.classList.remove(previousState);\n          }\n          previousState = \"isAtBottom\";\n          draggedOverOutline.classList.add(\"isAtBottom\");\n        }\n      }\n    }\n\n    //stop propagate to prevent dragover event from firing on parent element\n    event.stopPropagation();\n  });\n\n  //Dragleave: remove class from element when dragleave event is fired\n  elm.addEventListener('dragleave', function (event) {\n    event.preventDefault();\n\n    // console.log(\"previousState: \" + previousState);\n\n    if (previousState !== null) {\n      // draggedOverOutline.classList.remove(previousState);\n      draggedOverOutline.remove();\n      previousState = null;\n    }\n    draggedOverOutline = null;\n  });\n\n  //Drop: swap element with element being dragged\n  elm.addEventListener('drop', function (event) {\n    event.preventDefault();\n\n    //break if dragged element is same as element being dropped on\n    //also break if previousState is null\n    if (event.target.getAttribute(\"data-aperta-uuid\") === draggedElm.getAttribute(\"data-aperta-uuid\") || previousState === null) {\n      //console.log(\"same element\");\n      return;\n    }\n\n    //remove dragged element from previous position\n    draggedElm.parentNode.removeChild(draggedElm);\n\n    //insert dragged element into new position\n    if (event.target.tagName === \"BODY\") {\n      if (previousState === \"isAtTop\") {\n        event.target.prepend(draggedElm);\n        // draggedOverOutline.classList.remove(\"isAtTop\");\n      } else {\n        event.target.appendChild(draggedElm);\n        // draggedOverOutline.classList.remove(previousState);\n      }\n    } else {\n      //place dragged element before or after element being dropped on\n      if (previousState === \"isAtTop\") {\n        event.target.before(draggedElm);\n        // draggedOverOutline.classList.remove(\"isAtTop\");\n      } else if (previousState === \"isAtBottom\") {\n        event.target.after(draggedElm);\n        // draggedOverOutline.classList.remove(\"isAtBottom\");\n      } else if (previousState === \"middle\") {\n        //place dragged element as a child \n        event.target.appendChild(draggedElm);\n        // draggedOverOutline.classList.remove(\"middle\");\n      }\n    }\n\n    //\n    if (draggedOverOutline !== null) {\n      draggedOverOutline.remove();\n      draggedOverOutline = null;\n      previousState = null;\n    }\n\n    //reset Caption to selected element\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.addCaptionToSelectedElm)(draggedElm);\n  });\n}\n\n//# sourceURL=webpack://aperta/./views/webdesign/Utils/ElementEventListeners.js?");

/***/ }),

/***/ "./views/webdesign/Utils/ElementManager.js":
/*!*************************************************!*\
  !*** ./views/webdesign/Utils/ElementManager.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"elementManagerFactory\": () => (/* binding */ elementManagerFactory)\n/* harmony export */ });\nObject(function webpackMissingModule() { var e = new Error(\"Cannot find module '../ElementEventListeners.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"./views/webdesign/Utils/utils.js\");\n/* harmony import */ var _HtmlCategories_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./HtmlCategories.js */ \"./views/webdesign/Utils/HtmlCategories.js\");\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n//Event Listeners\n// import { addKeydownEventListeners } from \"./ElementEventListeners.js\";\n\n\n\n\n//\n\n//\n\n\n\n/* \n    *  Factory function to create an element manager from htag\n*/\n\n// factory function to create an element\nfunction elementManagerFactory(htag) {\n  // console.log(elm + \" \" + elm.tagName);\n  // return new Element();\n  switch (htag) {\n    case \"BODY\":\n      // console.log(\"body\" + htag)\n      return new BodyElementManager();\n    case \"H1\":\n    case \"H2\":\n    case \"H3\":\n    case \"H4\":\n    case \"H5\":\n    case \"H6\":\n      // console.log(\"heading\" + htag);\n      return new HeadingElementManager();\n    case \"IMG\":\n      return new ImgElementManager();\n    // add more cases here\n    default:\n      return new ElementManager();\n  }\n}\n\n/* \n    * Base class for HTML elements\n*/\nvar ElementManager = /*#__PURE__*/function () {\n  function ElementManager() {\n    _classCallCheck(this, ElementManager);\n  }\n  _createClass(ElementManager, [{\n    key: \"addElementToCanvas\",\n    value: function addElementToCanvas(htag, textContent) {\n      // Add the element to the canvas\n      var canvasWrapper = new _utils_js__WEBPACK_IMPORTED_MODULE_1__.CanvasWrapper();\n      var selectedElm = canvasWrapper.getSelectedElement();\n\n      // return if no element is selected\n      if (canvasWrapper.isSelectedElementNull()) {\n        return;\n      }\n      this.elm = this.createElement(htag);\n\n      // set default attributes to a new element\n      this.setDefaultAttributes(this.elm, textContent);\n\n      // Add event listeners to a new element\n      this.addListenerToElement(this.elm);\n\n      // Add element to canvas\n      this.addElmToSelectedElm(this.elm, selectedElm);\n    }\n\n    // create a new element\n    // override this method in child classes to create component consists of multiple elements\n  }, {\n    key: \"createElement\",\n    value: function createElement(htag) {\n      var elm = document.createElement(htag);\n      return elm;\n    }\n\n    // set default attributes to a new element\n    // override this method in child classes if needed\n  }, {\n    key: \"setDefaultAttributes\",\n    value: function setDefaultAttributes(elm, textContent) {\n      // Add default attributes\n      elm.textContent = textContent;\n      elm.setAttribute(\"draggable\", \"true\");\n      elm.setAttribute(\"data-aperta-uuid\", crypto.randomUUID());\n\n      //following styles are for development purposes delete later \n      elm.style.height = \"auto\";\n      elm.style.width = \"auto\";\n      elm.classList.add(\"aperta-element\");\n    }\n\n    // default event listeners add to an element\n    // override this method in child classes if needed\n  }, {\n    key: \"addListenerToElement\",\n    value: function addListenerToElement(elm) {\n      Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../ElementEventListeners.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())(elm);\n      Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../ElementEventListeners.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())(elm);\n      Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../ElementEventListeners.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())(elm);\n      Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../ElementEventListeners.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())(elm);\n    }\n\n    // add element to/after the selected element\n  }, {\n    key: \"addElmToSelectedElm\",\n    value: function addElmToSelectedElm(elm, selectedElm) {\n      if (selectedElm.tagName === \"BODY\") {\n        // Add element to selected element\n        selectedElm.appendChild(elm);\n      } else {\n        // Add element after selected element\n        selectedElm.after(elm);\n      }\n      (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.adjustBodyHeight)();\n    }\n\n    // check if the element can be a parent of the child element\n    // override this method in child classes \n    // refer https://html.spec.whatwg.org/multipage/semantics.html#semantics for specifcations\n    // use methods in HtmlCategories.js to check child elements belongs to which category\n    // also add conditions for exceptional cases if needed\n    // return true if an element can be a parent of a child element\n\n    // TODO: reconsider if return value should be true or false\n    // this is default implementation for development purposes\n    // change default return value (true) if needed\n  }, {\n    key: \"canBeParentOf\",\n    value: function canBeParentOf(child) {\n      return true;\n    }\n  }, {\n    key: \"getEnabledCssProperties\",\n    value: function getEnabledCssProperties() {\n      var enabledCssProperties = {\n        \"width\": true,\n        \"height\": true,\n        \"min-width\": true,\n        \"min-height\": true,\n        \"max-width\": true,\n        \"max-height\": true\n      };\n      return enabledCssProperties;\n    }\n  }]);\n  return ElementManager;\n}();\n/*\n    * Child classes for individual HTML elements (Categorize if possible)\n*/\n// Body element\n//\nvar BodyElementManager = /*#__PURE__*/function (_ElementManager) {\n  _inherits(BodyElementManager, _ElementManager);\n  var _super = _createSuper(BodyElementManager);\n  function BodyElementManager() {\n    _classCallCheck(this, BodyElementManager);\n    return _super.apply(this, arguments);\n  }\n  _createClass(BodyElementManager, [{\n    key: \"addListenerToElement\",\n    value: function addListenerToElement(elm) {\n      // addKeydownEventListeners(elm);\n      Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../ElementEventListeners.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())(elm);\n      Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../ElementEventListeners.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())(elm);\n      Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../ElementEventListeners.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())(elm);\n    }\n  }]);\n  return BodyElementManager;\n}(ElementManager); // Image element\n//\nvar ImgElementManager = /*#__PURE__*/function (_ElementManager2) {\n  _inherits(ImgElementManager, _ElementManager2);\n  var _super2 = _createSuper(ImgElementManager);\n  function ImgElementManager() {\n    _classCallCheck(this, ImgElementManager);\n    return _super2.apply(this, arguments);\n  }\n  _createClass(ImgElementManager, [{\n    key: \"setDefaultAttributes\",\n    value: function setDefaultAttributes(elm, textContent) {\n      // Create an element\n      // console.log(elm);\n      elm.src = \"../../img/imgPH.jpeg\";\n      elm.alt = textContent + \": placeholder\";\n      // elm.classList.add(\"canvasItem\");\n      elm.setAttribute(\"draggable\", \"true\");\n      elm.setAttribute(\"data-aperta-uuid\", crypto.randomUUID());\n    }\n  }]);\n  return ImgElementManager;\n}(ElementManager); // Heading element\n//\nvar HeadingElementManager = /*#__PURE__*/function (_ElementManager3) {\n  _inherits(HeadingElementManager, _ElementManager3);\n  var _super3 = _createSuper(HeadingElementManager);\n  function HeadingElementManager() {\n    _classCallCheck(this, HeadingElementManager);\n    return _super3.apply(this, arguments);\n  }\n  _createClass(HeadingElementManager, [{\n    key: \"canBeParentOf\",\n    value: function canBeParentOf(child) {\n      return (0,_HtmlCategories_js__WEBPACK_IMPORTED_MODULE_2__.isPhrasingContentTags)(child);\n    }\n  }]);\n  return HeadingElementManager;\n}(ElementManager);\n\n//# sourceURL=webpack://aperta/./views/webdesign/Utils/ElementManager.js?");

/***/ }),

/***/ "./views/webdesign/Utils/HtmlCategories.js":
/*!*************************************************!*\
  !*** ./views/webdesign/Utils/HtmlCategories.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"isEmbeddedContentTags\": () => (/* binding */ isEmbeddedContentTags),\n/* harmony export */   \"isFlowContentTags\": () => (/* binding */ isFlowContentTags),\n/* harmony export */   \"isHeadingContentTags\": () => (/* binding */ isHeadingContentTags),\n/* harmony export */   \"isInteractiveContentTags\": () => (/* binding */ isInteractiveContentTags),\n/* harmony export */   \"isMetadataContentTags\": () => (/* binding */ isMetadataContentTags),\n/* harmony export */   \"isPalpableContentTags\": () => (/* binding */ isPalpableContentTags),\n/* harmony export */   \"isPhrasingContentTags\": () => (/* binding */ isPhrasingContentTags),\n/* harmony export */   \"isSectioningContentTags\": () => (/* binding */ isSectioningContentTags)\n/* harmony export */ });\n/* \n    *  This file contains functions to check if the element is in the HTML category\n\n    *  made based on\n    *  https://html.spec.whatwg.org/multipage/dom.html#content-models\n    *  6 April 2023 version\n\n    *  Following functions are used to check if the element is in the category\n    *  functions mainly used in the ElementManager.js to check if the element can be parent of the element\n*/\n\n// Metadata content\n//\n\nfunction isMetadataContentTags(elm) {\n  var array = [\"BASE\", \"LINK\", \"META\", \"NOSCRIPT\", \"SCRIPT\", \"STYLE\", \"TEMPLATE\", \"TITLE\"];\n  if (array.includes(elm.tagName)) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\n// Flow content\n//\n\nfunction isFlowContentTags(elm) {\n  var array = [\"A\", \"ABBR\", \"ADDRESS\", \"ARTICLE\", \"ASIDE\", \"AUDIO\", \"B\", \"BDI\", \"BDO\", \"BLOCKQUOTE\", \"BR\", \"BUTTON\", \"CANVAS\", \"CITE\", \"CODE\", \"DATA\", \"DATALIST\", \"DEL\", \"DETAILS\", \"DFN\", \"DIALOG\", \"DIV\", \"DL\", \"EM\", \"EMBED\", \"FIELDSET\", \"FIGURE\", \"FOOTER\", \"FORM\", \"H1\", \"H2\", \"H3\", \"H4\", \"H5\", \"H6\", \"HEADER\", \"HGROUP\", \"HR\", \"I\", \"IFRAME\", \"IMG\", \"INPUT\", \"INS\", \"KBD\", \"LABEL\", \"LINK\",\n  //if it is allowed in the body element (if document is HTML5)\n  \"MAP\", \"MARK\", \"MATH\", \"MENU\", \"METER\", \"NAV\", \"NOSCRIPT\", \"OBJECT\", \"OL\", \"OUTPUT\", \"P\", \"PICTURE\", \"PRE\", \"PROGRESS\", \"Q\", \"RUBY\", \"S\", \"SAMP\", \"SCRIPT\", \"SEARCH\", \"SECTION\", \"SELECT\", \"SLOT\", \"SMALL\", \"SPAN\", \"STRONG\", \"SUB\", \"SUP\", \"SVG\", \"TABLE\", \"TEMPLATE\", \"TEXTAREA\", \"TIME\", \"U\", \"UL\", \"VAR\", \"VIDEO\", \"WBR\", \"TEXT\"];\n  if (array.includes(elm.tagName)) {\n    return true;\n  }\n\n  // check if conditional elements falls in to this category\n  switch (elm.tagName) {\n    case \"AREA\":\n      {\n        //if it is a descendant of a map element\n        if (elm.closest(\"map\") !== null) {\n          return true;\n        } else {\n          return false;\n        }\n      }\n    case \"MAIN\":\n      {\n        //if it is a hierarchically corrent main element\n        var ancestors = [\"DIV\", \"FORM\", \"BODY\", \"HTML\", \"CUSTOM-ELEMENT\"];\n        var parent = elm.parentElement;\n        while (parent !== null) {\n          if (ancestors.includes(parent.tagName)) {\n            return true;\n          }\n          parent = parent.parentElement;\n        }\n        return false;\n      }\n    case \"META\":\n      {\n        //if the itemprop attirbute is present\n        if (elm.hasAttribute(\"itemprop\")) {\n          return true;\n        } else {\n          return false;\n        }\n      }\n    default:\n      return false;\n  }\n}\n\n// Sectioning content\n//\n\nfunction isSectioningContentTags(elm) {\n  var array = [\"ARTICLE\", \"ASIDE\", \"NAV\", \"SECTION\"];\n  if (array.includes(elm.tagName)) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\n// Heading content\n//\n\nfunction isHeadingContentTags(elm) {\n  var array = [\"H1\", \"H2\", \"H3\", \"H4\", \"H5\", \"H6\"];\n  if (array.includes(elm.tagName)) {\n    return true;\n  }\n  if (elm.tagName === \"HGROUP\") {\n    if (elm.querySelector(\"h1, h2, h3, h4, h5, h6\") !== null) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n}\n\n// Phrasing content\n//\n\nfunction isPhrasingContentTags(elm) {\n  var array = [\"A\", \"ABBR\", \"AUDIO\", \"B\", \"BDI\", \"BDO\", \"BR\", \"BUTTON\", \"CANVAS\", \"CITE\", \"CODE\", \"DATA\", \"DATALIST\", \"DEL\", \"DFN\", \"EM\", \"EMBED\", \"I\", \"IFRAME\", \"IMG\", \"INPUT\", \"INS\", \"KBD\", \"LABEL\", \"LINK\",\n  //if it is allowed in the body element\n  \"MAP\", \"MARK\", \"MATH\", \"METER\", \"NOSCRIPT\", \"OBJECT\", \"OUTPUT\", \"PICTURE\", \"PROGRESS\", \"Q\", \"RUBY\", \"S\", \"SAMP\", \"SCRIPT\", \"SELECT\", \"SLOT\", \"SMALL\", \"SPAN\", \"STRONG\", \"SUB\", \"SUP\", \"SVG\", \"TEMPLATE\", \"TEXTAREA\", \"TIME\", \"U\", \"VAR\", \"VIDEO\", \"WBR\", \"TEXT\"];\n  if (array.includes(elm.tagName)) {\n    return true;\n  }\n  // check if conditional elements falls in to this category\n  switch (elm.tagName) {\n    case \"AREA\":\n      {\n        //if it is a descendant of a map element\n        if (elm.closest(\"map\") !== null) {\n          return true;\n        } else {\n          return false;\n        }\n      }\n    case \"META\":\n      {\n        //if the itemprop attirbute is present\n        if (elm.hasAttribute(\"itemprop\")) {\n          return true;\n        } else {\n          return false;\n        }\n      }\n    default:\n      return false;\n  }\n}\n\n// Embedded content\n//\n\nfunction isEmbeddedContentTags(elm) {\n  var array = [\"AUDIO\", \"CANVAS\", \"EMBED\", \"IFRAME\", \"IMG\", \"MATH\", \"OBJECT\", \"PICTURE\", \"SVG\", \"VIDEO\"];\n  if (array.includes(elm.tagName)) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\n// Interactive content\n//\n\nfunction isInteractiveContentTags(elm) {\n  var array = [\"BUTTON\", \"DETAILS\", \"EMBED\", \"IFRAME\", \"LABEL\", \"SELECT\", \"TEXTAREA\"];\n  if (array.includes(elm.tagName)) {\n    return true;\n  }\n  // check if conditional elements falls in to this category\n  switch (elm.tagName) {\n    case \"A\":\n      {\n        //if it has an href attribute\n        if (elm.hasAttribute(\"href\")) {\n          return true;\n        } else {\n          return false;\n        }\n      }\n    case \"AUDIO\":\n      {\n        //if it has a controls attribute\n        if (elm.hasAttribute(\"controls\")) {\n          return true;\n        } else {\n          return false;\n        }\n      }\n    case \"IMG\":\n      {\n        //if it has a usemap attribute\n        if (elm.hasAttribute(\"usemap\")) {\n          return true;\n        } else {\n          return false;\n        }\n      }\n    case \"INPUT\":\n      {\n        //if the type attribute is not in the Hidden state\n        if (elm.getAttribute(\"type\") !== \"hidden\") {\n          return true;\n        } else {\n          return false;\n        }\n      }\n    case \"VIDEO\":\n      {\n        //if it has a controls attribute\n        if (elm.hasAttribute(\"controls\")) {\n          return true;\n        } else {\n          return false;\n        }\n      }\n    default:\n      return false;\n  }\n}\n\n// Palpable content\n//\n\nfunction isPalpableContentTags(elm) {\n  var array = [\"A\", \"ABBR\", \"ADDRESS\", \"ARTICLE\", \"ASIDE\", \"AUDIO\",\n  //if it has a controls attribute\n  \"B\", \"BDI\", \"BDO\", \"BLOCKQUOTE\", \"BUTTON\", \"CANVAS\", \"CITE\", \"CODE\", \"DATA\", \"DEL\", \"DETAILS\", \"DFN\", \"DIV\", \"DL\",\n  //if the element's children include at least one name-value group\n  \"EM\", \"EMBED\", \"FIELDSET\", \"FIGURE\", \"FOOTER\", \"FORM\", \"H1\", \"H2\", \"H3\", \"H4\", \"H5\", \"H6\", \"HEADER\", \"HGROUP\", \"I\", \"IFRAME\", \"IMG\", \"INPUT\",\n  //if the element's type attribute is not in the Hidden state\n  \"INS\", \"KBD\", \"LABEL\", \"MAIN\", \"MAP\", \"MARK\", \"MATH\", \"MENU\",\n  //if the element's children include at least one li element\n  \"METER\", \"NAV\", \"OBJECT\", \"OL\",\n  //if the element's children include at least one li element\n  \"OUTPUT\", \"P\", \"PICTURE\", \"PRE\", \"PROGRESS\", \"Q\", \"RUBY\", \"S\", \"SAMP\", \"SEARCH\", \"SECTION\", \"SELECT\", \"SMALL\", \"SPAN\", \"STRONG\", \"SUB\", \"SUP\", \"SVG\", \"TABLE\", \"TEXTAREA\", \"TIME\", \"U\", \"UL\",\n  //if the element's children include at least one li element\n  \"VAR\", \"VIDEO\" //if it has a controls attribute\n  ];\n\n  if (array.includes(elm.tagName)) {\n    return true;\n  }\n  // check if conditional elements falls in to this category\n  switch (elm.tagName) {\n    case \"AUDIO\":\n      {\n        //if it has a controls attribute\n        if (elm.hasAttribute(\"controls\")) {\n          return true;\n        } else {\n          return false;\n        }\n      }\n    case \"DL\":\n      {\n        //if the element's children include at least one name-value group\n        if (elm.querySelector(\"dt\") !== null) {\n          return true;\n        }\n        if (elm.querySelector(\"dd\") !== null) {\n          return true;\n        } else {\n          return false;\n        }\n      }\n    case \"INPUT\":\n      {\n        //if the element's type attribute is not in the Hidden state\n        if (elm.getAttribute(\"type\") !== \"hidden\") {\n          return true;\n        } else {\n          return false;\n        }\n      }\n    case \"MENU\":\n      {\n        //if the element's children include at least one li element\n        if (elm.querySelector(\"li\") !== null) {\n          return true;\n        } else {\n          return false;\n        }\n      }\n    case \"OL\":\n      {\n        //if the element's children include at least one li element\n        if (elm.querySelector(\"li\") !== null) {\n          return true;\n        } else {\n          return false;\n        }\n      }\n    case \"UL\":\n      {\n        //if the element's children include at least one li element\n        if (elm.querySelector(\"li\") !== null) {\n          return true;\n        } else {\n          return false;\n        }\n      }\n    case \"VIDEO\":\n      {\n        //if it has a controls attribute\n        if (elm.hasAttribute(\"controls\")) {\n          return true;\n        } else {\n          return false;\n        }\n      }\n    default:\n      return false;\n  }\n}\n\n//# sourceURL=webpack://aperta/./views/webdesign/Utils/HtmlCategories.js?");

/***/ }),

/***/ "./views/webdesign/Utils/utils.js":
/*!****************************************!*\
  !*** ./views/webdesign/Utils/utils.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CanvasWrapper\": () => (/* binding */ CanvasWrapper),\n/* harmony export */   \"addCaptionToHoveredElm\": () => (/* binding */ addCaptionToHoveredElm),\n/* harmony export */   \"addCaptionToSelectedElm\": () => (/* binding */ addCaptionToSelectedElm),\n/* harmony export */   \"adjustBodyHeight\": () => (/* binding */ adjustBodyHeight),\n/* harmony export */   \"delCaptionFromHoveredElm\": () => (/* binding */ delCaptionFromHoveredElm),\n/* harmony export */   \"selectElm\": () => (/* binding */ selectElm)\n/* harmony export */ });\n/* harmony import */ var _CssStyleManager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CssStyleManager.js */ \"./views/webdesign/Utils/CssStyleManager.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\n\n/*\n    *  hovered elements related functions\n*/\n\n// add caption and outline to hovered element\nfunction addCaptionToHoveredElm(elm) {\n  // delete old hovered element before creating a new one\n  delCaptionFromHoveredElm(elm);\n\n  // get position of elm to calculate position for hovered element\n  var rect = elm.getBoundingClientRect();\n  var canvas = document.getElementById(\"canvas\");\n  var canvasWindow = canvas.contentWindow;\n  var absoluteRectTop = rect.top + canvasWindow.scrollY;\n  var absoluteRectBottom = rect.bottom + canvasWindow.scrollY;\n  var absoluteRectLeft = rect.left + canvasWindow.scrollX;\n  var absoluteRectRight = rect.right + canvasWindow.scrollX;\n\n  // create a label to show tagName\n  var hoverCaption = document.createElement(\"div\");\n  hoverCaption.textContent = elm.tagName;\n  hoverCaption.id = \"hoverCaption\";\n  hoverCaption.style.left = absoluteRectLeft + \"px\";\n  // new_elm.style.position = \"absolute\";\n  // new_elm.style.color = \"#1bbcf1\";\n  // new_elm.style.fontSize = \"10px\";\n  // new_elm.style.fontWeight = \"normal\";\n\n  // set position of hovered element\n  if (elm.tagName === \"BODY\") {\n    hoverCaption.style.top = absoluteRectTop + \"px\";\n  } else if (rect.top < 50) {\n    hoverCaption.style.top = absoluteRectBottom + 3 + \"px\";\n  } else {\n    hoverCaption.style.top = absoluteRectTop - 16 + \"px\";\n  }\n  elm.ownerDocument.body.after(hoverCaption);\n\n  // add outline to hovered element\n  var hoverOutline = document.createElement(\"div\");\n  hoverOutline.id = \"hoverOutline\";\n  hoverOutline.style.left = absoluteRectLeft + \"px\";\n  hoverOutline.style.top = absoluteRectTop + \"px\";\n  hoverOutline.style.width = absoluteRectRight - absoluteRectLeft + \"px\";\n  hoverOutline.style.height = absoluteRectBottom - absoluteRectTop + \"px\";\n  hoverCaption.after(hoverOutline);\n}\n\n// delete caption and outline from hovered element\n//\nfunction delCaptionFromHoveredElm(elm) {\n  // don't proceed to delete if there is no hovered element\n  if (elm === null) {\n    return;\n  }\n  var hoverCaption = elm.ownerDocument.getElementById(\"hoverCaption\");\n  var hoverOutline = elm.ownerDocument.getElementById(\"hoverOutline\");\n  if (hoverCaption !== null && hoverOutline !== null) {\n    hoverCaption.remove();\n    hoverOutline.remove();\n  }\n}\n\n/*\n    *  selected elements related functions\n*/\n\n// change state of selected elements\n//\nfunction selectElm(elm) {\n  var canvasWrapper = new CanvasWrapper();\n  var selectedElm = canvasWrapper.getSelectedElement();\n\n  // don't proceed if current selected element is the same as the new one\n  if (elm === selectedElm) {\n    return;\n  }\n  if (selectedElm !== undefined) {\n    //remove selectedElement id from previously selected element\n    selectedElm.removeAttribute(canvasWrapper.getSelectedElementAttributeName());\n  }\n\n  // add selectedElement attribute to newly selected element\n  elm.setAttribute(canvasWrapper.getSelectedElementAttributeName(), \"true\");\n  var cssStyleManager = new _CssStyleManager_js__WEBPACK_IMPORTED_MODULE_0__.CssStyleManager();\n  // console.log(cssStyleManager);\n\n  var elementSelectedEvent = new CustomEvent(\"elementSelected\", {\n    detail: {\n      target: elm,\n      targetStyle: cssStyleManager\n    }\n  });\n  document.dispatchEvent(elementSelectedEvent);\n}\n\n// add caption to selected element\n// TODO: add feature to edit element basic contents\n//\nfunction addCaptionToSelectedElm(elm) {\n  // delete old label and menu before creating a new one\n  var selectCaption = elm.ownerDocument.getElementById(\"selectCaption\");\n  var selectOutline = elm.ownerDocument.getElementById(\"selectOutline\");\n  if (selectCaption !== null && selectOutline !== null) {\n    selectCaption.remove();\n    selectOutline.remove();\n  }\n\n  // get position of hovered element\n  var rect = elm.getBoundingClientRect();\n  var canvas = document.getElementById(\"canvas\");\n  var canvasWindow = canvas.contentWindow;\n  var absoluteRectTop = rect.top + canvasWindow.scrollY;\n  var absoluteRectBottom = rect.bottom + canvasWindow.scrollY;\n  var absoluteRectLeft = rect.left + canvasWindow.scrollX;\n  var absoluteRectRight = rect.right + canvasWindow.scrollX;\n\n  // create a new label and menu element\n  selectCaption = document.createElement(\"div\");\n  selectCaption.textContent = elm.tagName;\n  selectCaption.id = \"selectCaption\";\n  selectCaption.style.left = absoluteRectLeft - 1 + \"px\";\n  // new_elm.style.position = \"absolute\";\n  // new_elm.style.color = \"#1bbcf1\";\n  // new_elm.style.fontSize = \"10px\";\n  // new_elm.style.fontWeight = \"normal\";\n\n  // set position of hovered element\n  if (elm.tagName === \"BODY\") {\n    selectCaption.style.top = absoluteRectTop + \"px\";\n  } else if (rect.top < 50) {\n    selectCaption.style.top = absoluteRectBottom + 3 + \"px\";\n  } else {\n    selectCaption.style.top = absoluteRectTop - 16 + \"px\";\n  }\n  elm.ownerDocument.body.after(selectCaption);\n\n  // add Outline to selected element\n  selectOutline = document.createElement(\"div\");\n  selectOutline.id = \"selectOutline\";\n  selectOutline.style.left = absoluteRectLeft + \"px\";\n  selectOutline.style.top = absoluteRectTop + \"px\";\n  selectOutline.style.width = absoluteRectRight - absoluteRectLeft + \"px\";\n  selectOutline.style.height = absoluteRectBottom - absoluteRectTop + \"px\";\n  selectCaption.after(selectOutline);\n}\n\n/*\n    *  util functions\n*/\n\n// use this class to get canvas related elements and attribute names to avoid hardcoding\n// TODO: consider to make it singleton to chache variables\nvar CanvasWrapper = /*#__PURE__*/function () {\n  function CanvasWrapper() {\n    _classCallCheck(this, CanvasWrapper);\n    this.canvas = document.getElementById(\"canvas\");\n    this.canvasWindow = this.canvas.contentWindow;\n    this.canvasDocument = this.canvasWindow.document;\n    // this.selectedElement = this.canvasDocument.getElementById(\"selectedElm\");\n    this.selectedElm = this.canvasDocument.querySelectorAll('[data-aperta-selected-element=\"true\"]')[0];\n  }\n\n  // constructor() {\n  //     if (CanvasWrapper.instance == null) {\n  //         this.selectedElementAttributeName = \"data-aperta-selected-element\";\n  //         this.canvas = document.getElementById(\"canvas\");\n  //         this.canvasWindow = this.canvas.contentWindow;\n  //         this.canvasDocument = this.canvasWindow.document;\n  //         // this.selectedElement = this.canvasDocument.getElementById(\"selectedElm\");\n  //         this.selectedElement = this.canvasDocument.querySelectorAll('[data-aperta-selected-element=\"true\"]')[0];\n  //         CanvasWrapper.instance = this;\n  //     } else {\n  //         return CanvasWrapper.instance;\n  //     }\n  // }\n\n  //update\n  // updateSelectedElement(elm) {\n  //     elm.setAttribute(this.selectedElementAttributeName, \"true\");\n  //     this.selectedElement = this.canvasDocument.querySelectorAll('[data-aperta-selected-element=\"true\"]')[0];\n  // }\n\n  //getters\n  _createClass(CanvasWrapper, [{\n    key: \"getCanvas\",\n    value: function getCanvas() {\n      return this.canvas;\n    }\n  }, {\n    key: \"getCanvasWindow\",\n    value: function getCanvasWindow() {\n      return this.canvasWindow;\n    }\n  }, {\n    key: \"getCanvasDocument\",\n    value: function getCanvasDocument() {\n      return this.canvasDocument;\n    }\n  }, {\n    key: \"getSelectedElement\",\n    value: function getSelectedElement() {\n      return this.selectedElm;\n    }\n  }, {\n    key: \"getSelectedElementAttributeName\",\n    value: function getSelectedElementAttributeName() {\n      // return \"selectedElm\";\n      return \"data-aperta-selected-element\";\n    }\n\n    //bool functions\n  }, {\n    key: \"isSelectedElement\",\n    value: function isSelectedElement(elm) {\n      // return elm.id === \"selectedElm\";\n      return elm === this.selectedElm;\n    }\n  }, {\n    key: \"isSelectedElementNull\",\n    value: function isSelectedElementNull() {\n      return this.selectedElm === undefined;\n    }\n  }, {\n    key: \"isElementSelected\",\n    value: function isElementSelected() {\n      return this.selectedElm !== undefined;\n    }\n  }]);\n  return CanvasWrapper;\n}();\n\n// function related to canvas appearance\n//\n\nfunction adjustBodyHeight() {\n  var canvas = document.getElementById(\"canvas\");\n  var canvasWindow = canvas.contentWindow;\n  var canvasWindowHeight = canvasWindow.innerHeight;\n  var canvasBody = canvasWindow.document.body;\n  var lastElmInBody = canvasBody.lastElementChild;\n  var absoluteRectBottom = lastElmInBody.getBoundingClientRect().bottom + canvasWindow.scrollY;\n\n  // console.log(\"lastElmY: \", lastElmY);\n\n  if (absoluteRectBottom < canvasWindowHeight) {\n    canvasBody.style.height = \"\".concat(canvasWindowHeight, \"px\");\n  } else {\n    canvasBody.style.height = absoluteRectBottom + 'px';\n    // canvasBody.style.height = 'auto';\n  }\n}\n\n//# sourceURL=webpack://aperta/./views/webdesign/Utils/utils.js?");

/***/ }),

/***/ "./views/webdesign/EditorCanvas/EditorCanvas.svelte":
/*!**********************************************************!*\
  !*** ./views/webdesign/EditorCanvas/EditorCanvas.svelte ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ \"./node_modules/svelte/internal/index.mjs\");\n/* harmony import */ var _Utils_ElementManager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Utils/ElementManager.js */ \"./views/webdesign/Utils/ElementManager.js\");\n/* harmony import */ var _Utils_ElementEventListeners_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Utils/ElementEventListeners.js */ \"./views/webdesign/Utils/ElementEventListeners.js\");\n/* views/webdesign/EditorCanvas/EditorCanvas.svelte generated by Svelte v3.58.0 */\n\n\n\n\n\nfunction add_css(target) {\n\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_styles)(target, \"svelte-p5qbh\", \".canvas.svelte-p5qbh{border:none;height:100%;width:100%}\");\n}\n\nfunction create_fragment(ctx) {\n\tlet iframe;\n\tlet iframe_src_value;\n\tlet mounted;\n\tlet dispose;\n\n\treturn {\n\t\tc() {\n\t\t\tiframe = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)(\"iframe\");\n\t\t\tif (!(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.src_url_equal)(iframe.src, iframe_src_value = \"./pageDesign/index.html\")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(iframe, \"src\", iframe_src_value);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(iframe, \"class\", \"canvas svelte-p5qbh\");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(iframe, \"id\", \"canvas\");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(iframe, \"title\", \"canvas\");\n\t\t},\n\t\tm(target, anchor) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, iframe, anchor);\n\t\t\t/*iframe_binding*/ ctx[2](iframe);\n\n\t\t\tif (!mounted) {\n\t\t\t\tdispose = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen)(iframe, \"load\", /*onCanvasLoad*/ ctx[1]);\n\t\t\t\tmounted = true;\n\t\t\t}\n\t\t},\n\t\tp: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,\n\t\ti: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,\n\t\to: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,\n\t\td(detaching) {\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(iframe);\n\t\t\t/*iframe_binding*/ ctx[2](null);\n\t\t\tmounted = false;\n\t\t\tdispose();\n\t\t}\n\t};\n}\n\nfunction instance($$self, $$props, $$invalidate) {\n\tlet canvas;\n\n\tconst onCanvasLoad = () => {\n\t\tconst canvasWindow = canvas.contentWindow;\n\t\t(0,_Utils_ElementEventListeners_js__WEBPACK_IMPORTED_MODULE_2__.addKeydownEventListeners)(canvasWindow);\n\t\tconst canvasBody = canvasWindow.document.body;\n\t\tconst allElementsIncludingBody = [canvasBody].concat(Array.from(canvasBody.getElementsByTagName(\"*\")));\n\t\tconsole.log(allElementsIncludingBody);\n\n\t\t// go through all the HTML elements on the page and add event listeners to them.\n\t\tfor (let i = 0; i < allElementsIncludingBody.length; i++) {\n\t\t\tconst elm = allElementsIncludingBody[i];\n\t\t\tconst elmManager = (0,_Utils_ElementManager_js__WEBPACK_IMPORTED_MODULE_1__.elementManagerFactory)(elm);\n\t\t\telmManager.addListenerToElement(elm);\n\t\t}\n\t}; // const elmManager = elementManagerFactory(canvasBody);\n\t// elmManager.addListenerToElement(canvasBody);\n\n\tfunction iframe_binding($$value) {\n\t\tsvelte_internal__WEBPACK_IMPORTED_MODULE_0__.binding_callbacks[$$value ? 'unshift' : 'push'](() => {\n\t\t\tcanvas = $$value;\n\t\t\t$$invalidate(0, canvas);\n\t\t});\n\t}\n\n\treturn [canvas, onCanvasLoad, iframe_binding];\n}\n\nclass EditorCanvas extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__.SvelteComponent {\n\tconstructor(options) {\n\t\tsuper();\n\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.init)(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal, {}, add_css);\n\t}\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EditorCanvas);\n\n//# sourceURL=webpack://aperta/./views/webdesign/EditorCanvas/EditorCanvas.svelte?");

/***/ }),

/***/ "./views/webdesign/RightSideMenu/ConnectionEditor/ConnectionEditor.svelte":
/*!********************************************************************************!*\
  !*** ./views/webdesign/RightSideMenu/ConnectionEditor/ConnectionEditor.svelte ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ \"./node_modules/svelte/internal/index.mjs\");\n/* harmony import */ var _CMSClient_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CMSClient.js */ \"./views/webdesign/RightSideMenu/ConnectionEditor/CMSClient.js\");\nObject(function webpackMissingModule() { var e = new Error(\"Cannot find module '../../utils.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n/* views/webdesign/RightSideMenu/ConnectionEditor/ConnectionEditor.svelte generated by Svelte v3.58.0 */\n\n\n\n\n\nfunction create_fragment(ctx) {\n\tlet button0;\n\tlet t1;\n\tlet br0;\n\tlet t2;\n\tlet select0;\n\tlet t3;\n\tlet br1;\n\tlet t4;\n\tlet button1;\n\tlet t6;\n\tlet br2;\n\tlet t7;\n\tlet select1;\n\tlet t8;\n\tlet br3;\n\tlet t9;\n\tlet button2;\n\tlet t11;\n\tlet br4;\n\tlet t12;\n\tlet select2;\n\tlet t13;\n\tlet br5;\n\tlet t14;\n\tlet button3;\n\tlet mounted;\n\tlet dispose;\n\n\treturn {\n\t\tc() {\n\t\t\tbutton0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)(\"button\");\n\t\t\tbutton0.textContent = \"get content Type\";\n\t\t\tt1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();\n\t\t\tbr0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)(\"br\");\n\t\t\tt2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();\n\t\t\tselect0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)(\"select\");\n\t\t\tt3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();\n\t\t\tbr1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)(\"br\");\n\t\t\tt4 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();\n\t\t\tbutton1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)(\"button\");\n\t\t\tbutton1.textContent = \"get contents\";\n\t\t\tt6 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();\n\t\t\tbr2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)(\"br\");\n\t\t\tt7 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();\n\t\t\tselect1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)(\"select\");\n\t\t\tt8 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();\n\t\t\tbr3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)(\"br\");\n\t\t\tt9 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();\n\t\t\tbutton2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)(\"button\");\n\t\t\tbutton2.textContent = \"get entries\";\n\t\t\tt11 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();\n\t\t\tbr4 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)(\"br\");\n\t\t\tt12 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();\n\t\t\tselect2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)(\"select\");\n\t\t\tt13 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();\n\t\t\tbr5 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)(\"br\");\n\t\t\tt14 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();\n\t\t\tbutton3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)(\"button\");\n\t\t\tbutton3.textContent = \"link contents\";\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(button0, \"id\", \"getContentType\");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(button1, \"id\", \"getContents\");\n\t\t},\n\t\tm(target, anchor) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, button0, anchor);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, t1, anchor);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, br0, anchor);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, t2, anchor);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, select0, anchor);\n\t\t\t/*select0_binding*/ ctx[4](select0);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, t3, anchor);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, br1, anchor);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, t4, anchor);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, button1, anchor);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, t6, anchor);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, br2, anchor);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, t7, anchor);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, select1, anchor);\n\t\t\t/*select1_binding*/ ctx[6](select1);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, t8, anchor);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, br3, anchor);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, t9, anchor);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, button2, anchor);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, t11, anchor);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, br4, anchor);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, t12, anchor);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, select2, anchor);\n\t\t\t/*select2_binding*/ ctx[8](select2);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, t13, anchor);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, br5, anchor);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, t14, anchor);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, button3, anchor);\n\n\t\t\tif (!mounted) {\n\t\t\t\tdispose = [\n\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen)(button0, \"click\", /*click_handler*/ ctx[3]),\n\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen)(button1, \"click\", /*click_handler_1*/ ctx[5]),\n\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen)(button2, \"click\", /*click_handler_2*/ ctx[7]),\n\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen)(button3, \"click\", /*click_handler_3*/ ctx[9])\n\t\t\t\t];\n\n\t\t\t\tmounted = true;\n\t\t\t}\n\t\t},\n\t\tp: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,\n\t\ti: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,\n\t\to: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,\n\t\td(detaching) {\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(button0);\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(t1);\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(br0);\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(t2);\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(select0);\n\t\t\t/*select0_binding*/ ctx[4](null);\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(t3);\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(br1);\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(t4);\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(button1);\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(t6);\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(br2);\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(t7);\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(select1);\n\t\t\t/*select1_binding*/ ctx[6](null);\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(t8);\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(br3);\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(t9);\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(button2);\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(t11);\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(br4);\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(t12);\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(select2);\n\t\t\t/*select2_binding*/ ctx[8](null);\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(t13);\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(br5);\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(t14);\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(button3);\n\t\t\tmounted = false;\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.run_all)(dispose);\n\t\t}\n\t};\n}\n\nfunction instance($$self, $$props, $$invalidate) {\n\tlet contentTypes;\n\tlet contents;\n\tlet entries;\n\tlet obj;\n\n\tconst click_handler = () => {\n\t\t// const contentfulConnector = new ContentfulConnector();\n\t\tconst contentfulConnector = new _CMSClient_js__WEBPACK_IMPORTED_MODULE_1__.ContentfulClient();\n\n\t\tcontentfulConnector.getContentType().then(obj => {\n\t\t\twhile (contentTypes.firstChild) {\n\t\t\t\tcontentTypes.removeChild(contentTypes.firstChild);\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < obj.items.length; i++) {\n\t\t\t\tconst option = document.createElement(\"option\");\n\t\t\t\toption.value = obj.items[i].sys.id;\n\t\t\t\toption.text = obj.items[i].name;\n\t\t\t\tcontentTypes.appendChild(option);\n\t\t\t}\n\t\t});\n\t};\n\n\tfunction select0_binding($$value) {\n\t\tsvelte_internal__WEBPACK_IMPORTED_MODULE_0__.binding_callbacks[$$value ? 'unshift' : 'push'](() => {\n\t\t\tcontentTypes = $$value;\n\t\t\t$$invalidate(0, contentTypes);\n\t\t});\n\t}\n\n\tconst click_handler_1 = () => {\n\t\t// console.log(contentTypes.value);\n\t\t// const contentfulConnector = new ContentfulConnector();\n\t\tconst contentfulConnector = new _CMSClient_js__WEBPACK_IMPORTED_MODULE_1__.ContentfulClient();\n\n\t\tcontentfulConnector.getContents(contentTypes.value).then(obj => {\n\t\t\twhile (contents.firstChild) {\n\t\t\t\tcontents.removeChild(contents.firstChild);\n\t\t\t}\n\n\t\t\tconsole.log(obj.items);\n\n\t\t\tfor (let i = 0; i < obj.items.length; i++) {\n\t\t\t\tconst option = document.createElement(\"option\");\n\t\t\t\toption.value = obj.items[i].sys.id;\n\t\t\t\toption.text = obj.items[i].fields.title;\n\t\t\t\tcontents.appendChild(option);\n\t\t\t}\n\t\t});\n\t};\n\n\tfunction select1_binding($$value) {\n\t\tsvelte_internal__WEBPACK_IMPORTED_MODULE_0__.binding_callbacks[$$value ? 'unshift' : 'push'](() => {\n\t\t\tcontents = $$value;\n\t\t\t$$invalidate(1, contents);\n\t\t});\n\t}\n\n\tconst click_handler_2 = () => {\n\t\t// console.log(contents.value);\n\t\t// const contentfulConnector = new ContentfulConnector();\n\t\tconst contentfulConnector = new _CMSClient_js__WEBPACK_IMPORTED_MODULE_1__.ContentfulClient();\n\n\t\tcontentfulConnector.getEntry(contents.value).then(obj => {\n\t\t\twhile (entries.firstChild) {\n\t\t\t\tentries.removeChild(entries.firstChild);\n\t\t\t}\n\n\t\t\tconsole.log(Object.keys(obj.fields));\n\t\t\tconst key = Object.keys(obj.fields);\n\n\t\t\tfor (let i = 0; i < key.length; i++) {\n\t\t\t\tconst option = document.createElement(\"option\");\n\t\t\t\toption.value = obj.fields[key[i]];\n\t\t\t\toption.text = key[i];\n\t\t\t\tentries.appendChild(option);\n\t\t\t}\n\t\t}); // for (let i = 0; i < obj.fields.length; i++) {\n\t\t//     const option = document.createElement(\"option\");\n\t\t//     option.value = obj.fields[i].name;\n\t\t//     option.text = obj.fields[i].title;\n\t}; //     entries.appendChild(option);\n\t// }\n\n\tfunction select2_binding($$value) {\n\t\tsvelte_internal__WEBPACK_IMPORTED_MODULE_0__.binding_callbacks[$$value ? 'unshift' : 'push'](() => {\n\t\t\tentries = $$value;\n\t\t\t$$invalidate(2, entries);\n\t\t});\n\t}\n\n\tconst click_handler_3 = () => {\n\t\tconst canvasWrapper = new Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../../utils.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())();\n\t\tconst selectedElm = canvasWrapper.getSelectedElement();\n\n\t\t// const canvas = document.getElementById(\"canvas\");\n\t\t// const canvasWindow = canvas.contentWindow;\n\t\t// const canvasDocument = canvasWindow.document;\n\t\t// const selectedElement = canvasDocument.getElementById(\"selectedElm\");\n\t\tselectedElm.innerHTML = entries.value;\n\t};\n\n\treturn [\n\t\tcontentTypes,\n\t\tcontents,\n\t\tentries,\n\t\tclick_handler,\n\t\tselect0_binding,\n\t\tclick_handler_1,\n\t\tselect1_binding,\n\t\tclick_handler_2,\n\t\tselect2_binding,\n\t\tclick_handler_3\n\t];\n}\n\nclass ConnectionEditor extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__.SvelteComponent {\n\tconstructor(options) {\n\t\tsuper();\n\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.init)(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal, {});\n\t}\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ConnectionEditor);\n\n//# sourceURL=webpack://aperta/./views/webdesign/RightSideMenu/ConnectionEditor/ConnectionEditor.svelte?");

/***/ }),

/***/ "./views/webdesign/RightSideMenu/RightSideMenu.svelte":
/*!************************************************************!*\
  !*** ./views/webdesign/RightSideMenu/RightSideMenu.svelte ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ \"./node_modules/svelte/internal/index.mjs\");\nObject(function webpackMissingModule() { var e = new Error(\"Cannot find module '../CssEditor.svelte'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n/* harmony import */ var _ConnectionEditor_ConnectionEditor_svelte__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ConnectionEditor/ConnectionEditor.svelte */ \"./views/webdesign/RightSideMenu/ConnectionEditor/ConnectionEditor.svelte\");\n/* harmony import */ var _RightSideMenuTabs_svelte__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RightSideMenuTabs.svelte */ \"./views/webdesign/RightSideMenu/RightSideMenuTabs.svelte\");\n/* views/webdesign/RightSideMenu/RightSideMenu.svelte generated by Svelte v3.58.0 */\n\n\n\n\n\n\nfunction create_fragment(ctx) {\n\tlet rightsidemenutabs;\n\tlet current;\n\n\trightsidemenutabs = new _RightSideMenuTabs_svelte__WEBPACK_IMPORTED_MODULE_3__[\"default\"]({\n\t\t\tprops: {\n\t\t\t\trightSideMenuTabItems: /*rightSideMenuTabItems*/ ctx[0]\n\t\t\t}\n\t\t});\n\n\treturn {\n\t\tc() {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(rightsidemenutabs.$$.fragment);\n\t\t},\n\t\tm(target, anchor) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(rightsidemenutabs, target, anchor);\n\t\t\tcurrent = true;\n\t\t},\n\t\tp: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,\n\t\ti(local) {\n\t\t\tif (current) return;\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(rightsidemenutabs.$$.fragment, local);\n\t\t\tcurrent = true;\n\t\t},\n\t\to(local) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(rightsidemenutabs.$$.fragment, local);\n\t\t\tcurrent = false;\n\t\t},\n\t\td(detaching) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(rightsidemenutabs, detaching);\n\t\t}\n\t};\n}\n\nfunction instance($$self) {\n\tconst rightSideMenuTabItems = [\n\t\t// add new tab here if needed\n\t\t{\n\t\t\tlabel: \"css\",\n\t\t\tvalue: 1,\n\t\t\tcomponent: Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../CssEditor.svelte'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())\n\t\t},\n\t\t{\n\t\t\tlabel: \"cms\",\n\t\t\tvalue: 2,\n\t\t\tcomponent: _ConnectionEditor_ConnectionEditor_svelte__WEBPACK_IMPORTED_MODULE_2__[\"default\"]\n\t\t}\n\t];\n\n\treturn [rightSideMenuTabItems];\n}\n\nclass RightSideMenu extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__.SvelteComponent {\n\tconstructor(options) {\n\t\tsuper();\n\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.init)(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal, {});\n\t}\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RightSideMenu);\n\n//# sourceURL=webpack://aperta/./views/webdesign/RightSideMenu/RightSideMenu.svelte?");

/***/ }),

/***/ "./views/webdesign/RightSideMenu/RightSideMenuTabs.svelte":
/*!****************************************************************!*\
  !*** ./views/webdesign/RightSideMenu/RightSideMenuTabs.svelte ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ \"./node_modules/svelte/internal/index.mjs\");\n/* harmony import */ var svelte__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! svelte */ \"./node_modules/svelte/index.mjs\");\nObject(function webpackMissingModule() { var e = new Error(\"Cannot find module '../utils'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nObject(function webpackMissingModule() { var e = new Error(\"Cannot find module '../CssStore.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n/* views/webdesign/RightSideMenu/RightSideMenuTabs.svelte generated by Svelte v3.58.0 */\n\n\n\n\n\n\nfunction add_css(target) {\n\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_styles)(target, \"svelte-qg3xv9\", \"ul.svelte-qg3xv9.svelte-qg3xv9{display:flex;flex-wrap:wrap;padding-left:0;margin-bottom:0;list-style:none;border-bottom:1px solid #dee2e6}li.svelte-qg3xv9.svelte-qg3xv9{margin-bottom:-1px}span.svelte-qg3xv9.svelte-qg3xv9{border:1px solid transparent;border-top-left-radius:0.25rem;border-top-right-radius:0.25rem;display:block;padding:0.5rem 1rem;cursor:pointer}span.svelte-qg3xv9.svelte-qg3xv9:hover{border-color:#e9ecef #e9ecef #dee2e6}li.active.svelte-qg3xv9>span.svelte-qg3xv9{color:#495057;background-color:#fff;border-color:#dee2e6 #dee2e6 #fff}.hidden.svelte-qg3xv9.svelte-qg3xv9{display:none}.box.svelte-qg3xv9.svelte-qg3xv9{width:100%;height:100%;margin-bottom:10px;border:1px solid #dee2e6;border-radius:0 0 0.5rem 0.5rem;border-top:0}\");\n}\n\nfunction get_each_context(ctx, list, i) {\n\tconst child_ctx = ctx.slice();\n\tchild_ctx[4] = list[i];\n\treturn child_ctx;\n}\n\nfunction get_each_context_1(ctx, list, i) {\n\tconst child_ctx = ctx.slice();\n\tchild_ctx[1] = list[i];\n\treturn child_ctx;\n}\n\n// (12:4) {#each rightSideMenuTabItems as rightSideMenuTabItems}\nfunction create_each_block_1(ctx) {\n\tlet li;\n\tlet span;\n\tlet t0_value = /*rightSideMenuTabItems*/ ctx[1].label + \"\";\n\tlet t0;\n\tlet t1;\n\tlet li_class_value;\n\tlet mounted;\n\tlet dispose;\n\n\treturn {\n\t\tc() {\n\t\t\tli = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)(\"li\");\n\t\t\tspan = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)(\"span\");\n\t\t\tt0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(t0_value);\n\t\t\tt1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(span, \"class\", \"svelte-qg3xv9\");\n\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(li, \"class\", li_class_value = \"\" + ((0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.null_to_empty)(/*activeTabValue*/ ctx[0] === /*rightSideMenuTabItems*/ ctx[1].value\n\t\t\t? \"active\"\n\t\t\t: \"\") + \" svelte-qg3xv9\"));\n\t\t},\n\t\tm(target, anchor) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, li, anchor);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(li, span);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(span, t0);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(li, t1);\n\n\t\t\tif (!mounted) {\n\t\t\t\tdispose = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen)(span, \"click\", function () {\n\t\t\t\t\tif ((0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.is_function)(/*handleClick*/ ctx[3](/*rightSideMenuTabItems*/ ctx[1].value))) /*handleClick*/ ctx[3](/*rightSideMenuTabItems*/ ctx[1].value).apply(this, arguments);\n\t\t\t\t});\n\n\t\t\t\tmounted = true;\n\t\t\t}\n\t\t},\n\t\tp(new_ctx, dirty) {\n\t\t\tctx = new_ctx;\n\t\t\tif (dirty & /*rightSideMenuTabItems*/ 2 && t0_value !== (t0_value = /*rightSideMenuTabItems*/ ctx[1].label + \"\")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data)(t0, t0_value);\n\n\t\t\tif (dirty & /*activeTabValue, rightSideMenuTabItems*/ 3 && li_class_value !== (li_class_value = \"\" + ((0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.null_to_empty)(/*activeTabValue*/ ctx[0] === /*rightSideMenuTabItems*/ ctx[1].value\n\t\t\t? \"active\"\n\t\t\t: \"\") + \" svelte-qg3xv9\"))) {\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(li, \"class\", li_class_value);\n\t\t\t}\n\t\t},\n\t\td(detaching) {\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(li);\n\t\t\tmounted = false;\n\t\t\tdispose();\n\t\t}\n\t};\n}\n\n// (26:0) {#each rightSideMenuTabItems as rightSideMenuTabItem}\nfunction create_each_block(ctx) {\n\tlet div;\n\tlet switch_instance;\n\tlet t;\n\tlet div_class_value;\n\tlet current;\n\tvar switch_value = /*rightSideMenuTabItem*/ ctx[4].component;\n\n\tfunction switch_props(ctx) {\n\t\treturn {};\n\t}\n\n\tif (switch_value) {\n\t\tswitch_instance = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.construct_svelte_component)(switch_value, switch_props(ctx));\n\t}\n\n\treturn {\n\t\tc() {\n\t\t\tdiv = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)(\"div\");\n\t\t\tif (switch_instance) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(switch_instance.$$.fragment);\n\t\t\tt = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();\n\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(div, \"class\", div_class_value = \"box \" + (/*$cssStyleManager*/ ctx[2] !== null && /*activeTabValue*/ ctx[0] == /*rightSideMenuTabItem*/ ctx[4].value\n\t\t\t? ''\n\t\t\t: 'hidden') + \" svelte-qg3xv9\");\n\t\t},\n\t\tm(target, anchor) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, div, anchor);\n\t\t\tif (switch_instance) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(switch_instance, div, null);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(div, t);\n\t\t\tcurrent = true;\n\t\t},\n\t\tp(ctx, dirty) {\n\t\t\tif (dirty & /*rightSideMenuTabItems*/ 2 && switch_value !== (switch_value = /*rightSideMenuTabItem*/ ctx[4].component)) {\n\t\t\t\tif (switch_instance) {\n\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();\n\t\t\t\t\tconst old_component = switch_instance;\n\n\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(old_component.$$.fragment, 1, 0, () => {\n\t\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(old_component, 1);\n\t\t\t\t\t});\n\n\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();\n\t\t\t\t}\n\n\t\t\t\tif (switch_value) {\n\t\t\t\t\tswitch_instance = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.construct_svelte_component)(switch_value, switch_props(ctx));\n\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(switch_instance.$$.fragment);\n\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(switch_instance.$$.fragment, 1);\n\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(switch_instance, div, t);\n\t\t\t\t} else {\n\t\t\t\t\tswitch_instance = null;\n\t\t\t\t}\n\t\t\t} else if (switch_value) {\n\t\t\t\t\n\t\t\t}\n\n\t\t\tif (!current || dirty & /*$cssStyleManager, activeTabValue, rightSideMenuTabItems*/ 7 && div_class_value !== (div_class_value = \"box \" + (/*$cssStyleManager*/ ctx[2] !== null && /*activeTabValue*/ ctx[0] == /*rightSideMenuTabItem*/ ctx[4].value\n\t\t\t? ''\n\t\t\t: 'hidden') + \" svelte-qg3xv9\")) {\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(div, \"class\", div_class_value);\n\t\t\t}\n\t\t},\n\t\ti(local) {\n\t\t\tif (current) return;\n\t\t\tif (switch_instance) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(switch_instance.$$.fragment, local);\n\t\t\tcurrent = true;\n\t\t},\n\t\to(local) {\n\t\t\tif (switch_instance) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(switch_instance.$$.fragment, local);\n\t\t\tcurrent = false;\n\t\t},\n\t\td(detaching) {\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(div);\n\t\t\tif (switch_instance) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(switch_instance);\n\t\t}\n\t};\n}\n\nfunction create_fragment(ctx) {\n\tlet ul;\n\tlet t;\n\tlet each1_anchor;\n\tlet current;\n\tlet each_value_1 = /*rightSideMenuTabItems*/ ctx[1];\n\tlet each_blocks_1 = [];\n\n\tfor (let i = 0; i < each_value_1.length; i += 1) {\n\t\teach_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));\n\t}\n\n\tlet each_value = /*rightSideMenuTabItems*/ ctx[1];\n\tlet each_blocks = [];\n\n\tfor (let i = 0; i < each_value.length; i += 1) {\n\t\teach_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));\n\t}\n\n\tconst out = i => (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(each_blocks[i], 1, 1, () => {\n\t\teach_blocks[i] = null;\n\t});\n\n\treturn {\n\t\tc() {\n\t\t\tul = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)(\"ul\");\n\n\t\t\tfor (let i = 0; i < each_blocks_1.length; i += 1) {\n\t\t\t\teach_blocks_1[i].c();\n\t\t\t}\n\n\t\t\tt = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();\n\n\t\t\tfor (let i = 0; i < each_blocks.length; i += 1) {\n\t\t\t\teach_blocks[i].c();\n\t\t\t}\n\n\t\t\teach1_anchor = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.empty)();\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(ul, \"class\", \"svelte-qg3xv9\");\n\t\t},\n\t\tm(target, anchor) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, ul, anchor);\n\n\t\t\tfor (let i = 0; i < each_blocks_1.length; i += 1) {\n\t\t\t\tif (each_blocks_1[i]) {\n\t\t\t\t\teach_blocks_1[i].m(ul, null);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, t, anchor);\n\n\t\t\tfor (let i = 0; i < each_blocks.length; i += 1) {\n\t\t\t\tif (each_blocks[i]) {\n\t\t\t\t\teach_blocks[i].m(target, anchor);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, each1_anchor, anchor);\n\t\t\tcurrent = true;\n\t\t},\n\t\tp(ctx, [dirty]) {\n\t\t\tif (dirty & /*activeTabValue, rightSideMenuTabItems, handleClick*/ 11) {\n\t\t\t\teach_value_1 = /*rightSideMenuTabItems*/ ctx[1];\n\t\t\t\tlet i;\n\n\t\t\t\tfor (i = 0; i < each_value_1.length; i += 1) {\n\t\t\t\t\tconst child_ctx = get_each_context_1(ctx, each_value_1, i);\n\n\t\t\t\t\tif (each_blocks_1[i]) {\n\t\t\t\t\t\teach_blocks_1[i].p(child_ctx, dirty);\n\t\t\t\t\t} else {\n\t\t\t\t\t\teach_blocks_1[i] = create_each_block_1(child_ctx);\n\t\t\t\t\t\teach_blocks_1[i].c();\n\t\t\t\t\t\teach_blocks_1[i].m(ul, null);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (; i < each_blocks_1.length; i += 1) {\n\t\t\t\t\teach_blocks_1[i].d(1);\n\t\t\t\t}\n\n\t\t\t\teach_blocks_1.length = each_value_1.length;\n\t\t\t}\n\n\t\t\tif (dirty & /*$cssStyleManager, activeTabValue, rightSideMenuTabItems*/ 7) {\n\t\t\t\teach_value = /*rightSideMenuTabItems*/ ctx[1];\n\t\t\t\tlet i;\n\n\t\t\t\tfor (i = 0; i < each_value.length; i += 1) {\n\t\t\t\t\tconst child_ctx = get_each_context(ctx, each_value, i);\n\n\t\t\t\t\tif (each_blocks[i]) {\n\t\t\t\t\t\teach_blocks[i].p(child_ctx, dirty);\n\t\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(each_blocks[i], 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\teach_blocks[i] = create_each_block(child_ctx);\n\t\t\t\t\t\teach_blocks[i].c();\n\t\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(each_blocks[i], 1);\n\t\t\t\t\t\teach_blocks[i].m(each1_anchor.parentNode, each1_anchor);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();\n\n\t\t\t\tfor (i = each_value.length; i < each_blocks.length; i += 1) {\n\t\t\t\t\tout(i);\n\t\t\t\t}\n\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();\n\t\t\t}\n\t\t},\n\t\ti(local) {\n\t\t\tif (current) return;\n\n\t\t\tfor (let i = 0; i < each_value.length; i += 1) {\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(each_blocks[i]);\n\t\t\t}\n\n\t\t\tcurrent = true;\n\t\t},\n\t\to(local) {\n\t\t\teach_blocks = each_blocks.filter(Boolean);\n\n\t\t\tfor (let i = 0; i < each_blocks.length; i += 1) {\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(each_blocks[i]);\n\t\t\t}\n\n\t\t\tcurrent = false;\n\t\t},\n\t\td(detaching) {\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(ul);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_each)(each_blocks_1, detaching);\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(t);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_each)(each_blocks, detaching);\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(each1_anchor);\n\t\t}\n\t};\n}\n\nfunction instance($$self, $$props, $$invalidate) {\n\tlet $cssStyleManager;\n\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.component_subscribe)($$self, Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../CssStore.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()), $$value => $$invalidate(2, $cssStyleManager = $$value));\n\tlet { rightSideMenuTabItems = [] } = $$props;\n\tlet { activeTabValue = 1 } = $$props;\n\tconst handleClick = tabValue => () => $$invalidate(0, activeTabValue = tabValue);\n\n\t$$self.$$set = $$props => {\n\t\tif ('rightSideMenuTabItems' in $$props) $$invalidate(1, rightSideMenuTabItems = $$props.rightSideMenuTabItems);\n\t\tif ('activeTabValue' in $$props) $$invalidate(0, activeTabValue = $$props.activeTabValue);\n\t};\n\n\treturn [activeTabValue, rightSideMenuTabItems, $cssStyleManager, handleClick];\n}\n\nclass RightSideMenuTabs extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__.SvelteComponent {\n\tconstructor(options) {\n\t\tsuper();\n\n\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.init)(\n\t\t\tthis,\n\t\t\toptions,\n\t\t\tinstance,\n\t\t\tcreate_fragment,\n\t\t\tsvelte_internal__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal,\n\t\t\t{\n\t\t\t\trightSideMenuTabItems: 1,\n\t\t\t\tactiveTabValue: 0\n\t\t\t},\n\t\t\tadd_css\n\t\t);\n\t}\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RightSideMenuTabs);\n\n//# sourceURL=webpack://aperta/./views/webdesign/RightSideMenu/RightSideMenuTabs.svelte?");

/***/ }),

/***/ "./views/webdesign/WebDesign.svelte":
/*!******************************************!*\
  !*** ./views/webdesign/WebDesign.svelte ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ \"./node_modules/svelte/internal/index.mjs\");\nObject(function webpackMissingModule() { var e = new Error(\"Cannot find module './LeftSideMenu/LeftSideMenu.svelte'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n/* harmony import */ var _EditorCanvas_EditorCanvas_svelte__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EditorCanvas/EditorCanvas.svelte */ \"./views/webdesign/EditorCanvas/EditorCanvas.svelte\");\n/* harmony import */ var _RightSideMenu_RightSideMenu_svelte__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RightSideMenu/RightSideMenu.svelte */ \"./views/webdesign/RightSideMenu/RightSideMenu.svelte\");\n/* views/webdesign/WebDesign.svelte generated by Svelte v3.58.0 */\n\n\n\n\n\n// import MetaEditor from \"./RightSideMenu.svelte\";\n\n\nfunction add_css(target) {\n\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_styles)(target, \"svelte-rz7fgr\", \".wrapper.svelte-rz7fgr{position:fixed;top:0px;left:0px;width:100vw;height:100vh;margin:0px;outline:1px solid gray;display:flex;flex-flow:column;overflow:hidden}.header.svelte-rz7fgr{width:100%;text-align:center;outline:1px solid gray}.workspace.svelte-rz7fgr{flex:1;outline:1px solid gray;display:flex}.footer.svelte-rz7fgr{width:100%;text-align:center;outline:1px solid gray}.editor.svelte-rz7fgr{width:100%;padding:10px;outline:1px solid gray}.rightSideMenu.svelte-rz7fgr{height:100%;outline:1px solid gray}.metaEditorTab.svelte-rz7fgr{width:225px}\");\n}\n\nfunction create_fragment(ctx) {\n\tlet div7;\n\tlet div0;\n\tlet t1;\n\tlet div5;\n\tlet div1;\n\tlet leftsidemenu;\n\tlet t2;\n\tlet div2;\n\tlet editorcanvas;\n\tlet t3;\n\tlet div4;\n\tlet div3;\n\tlet rightsidemenu;\n\tlet t4;\n\tlet div6;\n\tlet current;\n\tleftsidemenu = new Object(function webpackMissingModule() { var e = new Error(\"Cannot find module './LeftSideMenu/LeftSideMenu.svelte'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())({});\n\teditorcanvas = new _EditorCanvas_EditorCanvas_svelte__WEBPACK_IMPORTED_MODULE_2__[\"default\"]({});\n\trightsidemenu = new _RightSideMenu_RightSideMenu_svelte__WEBPACK_IMPORTED_MODULE_3__[\"default\"]({});\n\n\treturn {\n\t\tc() {\n\t\t\tdiv7 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)(\"div\");\n\t\t\tdiv0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)(\"div\");\n\t\t\tdiv0.textContent = \"Header\";\n\t\t\tt1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();\n\t\t\tdiv5 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)(\"div\");\n\t\t\tdiv1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)(\"div\");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(leftsidemenu.$$.fragment);\n\t\t\tt2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();\n\t\t\tdiv2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)(\"div\");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(editorcanvas.$$.fragment);\n\t\t\tt3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();\n\t\t\tdiv4 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)(\"div\");\n\t\t\tdiv3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)(\"div\");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(rightsidemenu.$$.fragment);\n\t\t\tt4 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();\n\t\t\tdiv6 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)(\"div\");\n\t\t\tdiv6.textContent = \"footer\";\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(div0, \"class\", \"header svelte-rz7fgr\");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(div1, \"class\", \"leftSideMenu\");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(div2, \"class\", \"editor svelte-rz7fgr\");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(div3, \"class\", \"metaEditorTab svelte-rz7fgr\");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(div4, \"class\", \"rightSideMenu svelte-rz7fgr\");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(div5, \"class\", \"workspace svelte-rz7fgr\");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(div6, \"class\", \"footer svelte-rz7fgr\");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(div7, \"class\", \"wrapper svelte-rz7fgr\");\n\t\t},\n\t\tm(target, anchor) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, div7, anchor);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(div7, div0);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(div7, t1);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(div7, div5);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(div5, div1);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(leftsidemenu, div1, null);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(div5, t2);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(div5, div2);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(editorcanvas, div2, null);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(div5, t3);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(div5, div4);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(div4, div3);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(rightsidemenu, div3, null);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(div7, t4);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(div7, div6);\n\t\t\tcurrent = true;\n\t\t},\n\t\tp: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,\n\t\ti(local) {\n\t\t\tif (current) return;\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(leftsidemenu.$$.fragment, local);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(editorcanvas.$$.fragment, local);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(rightsidemenu.$$.fragment, local);\n\t\t\tcurrent = true;\n\t\t},\n\t\to(local) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(leftsidemenu.$$.fragment, local);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(editorcanvas.$$.fragment, local);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(rightsidemenu.$$.fragment, local);\n\t\t\tcurrent = false;\n\t\t},\n\t\td(detaching) {\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(div7);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(leftsidemenu);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(editorcanvas);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(rightsidemenu);\n\t\t}\n\t};\n}\n\nclass WebDesign extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__.SvelteComponent {\n\tconstructor(options) {\n\t\tsuper();\n\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.init)(this, options, null, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal, {}, add_css);\n\t}\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WebDesign);\n\n//# sourceURL=webpack://aperta/./views/webdesign/WebDesign.svelte?");

/***/ }),

/***/ "./node_modules/specificity/dist/specificity.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/specificity/dist/specificity.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"calculate\": () => (/* binding */ calculate),\n/* harmony export */   \"compare\": () => (/* binding */ compare)\n/* harmony export */ });\n// Calculate the specificity for a selector by dividing it into simple selectors and counting them\nvar calculate = function(input) {\n\tvar selectors,\n\t\tselector,\n\t\ti,\n\t\tlen,\n\t\tresults = [];\n\n\t// Separate input by commas\n\tselectors = input.split(',');\n\n\tfor (i = 0, len = selectors.length; i < len; i += 1) {\n\t\tselector = selectors[i];\n\t\tif (selector.length > 0) {\n\t\t\tresults.push(calculateSingle(selector));\n\t\t}\n\t}\n\n\treturn results;\n};\n\n/**\n * Calculates the specificity of CSS selectors\n * http://www.w3.org/TR/css3-selectors/#specificity\n *\n * Returns an object with the following properties:\n *  - selector: the input\n *  - specificity: e.g. 0,1,0,0\n *  - parts: array with details about each part of the selector that counts towards the specificity\n *  - specificityArray: e.g. [0, 1, 0, 0]\n */\nvar calculateSingle = function(input) {\n\tvar selector = input,\n\t\tfindMatch,\n\t\ttypeCount = {\n\t\t\t'a': 0,\n\t\t\t'b': 0,\n\t\t\t'c': 0\n\t\t},\n\t\tparts = [],\n\t\t// The following regular expressions assume that selectors matching the preceding regular expressions have been removed\n\t\tattributeRegex = /(\\[[^\\]]+\\])/g,\n\t\tidRegex = /(#[^\\#\\s\\+>~\\.\\[:\\)]+)/g,\n\t\tclassRegex = /(\\.[^\\s\\+>~\\.\\[:\\)]+)/g,\n\t\tpseudoElementRegex = /(::[^\\s\\+>~\\.\\[:]+|:first-line|:first-letter|:before|:after)/gi,\n\t\t// A regex for pseudo classes with brackets - :nth-child(), :nth-last-child(), :nth-of-type(), :nth-last-type(), :lang()\n\t\t// The negation psuedo class (:not) is filtered out because specificity is calculated on its argument\n\t\t// :global and :local are filtered out - they look like psuedo classes but are an identifier for CSS Modules\n\t\tpseudoClassWithBracketsRegex = /(:(?!not|global|local)[\\w-]+\\([^\\)]*\\))/gi,\n\t\t// A regex for other pseudo classes, which don't have brackets\n\t\tpseudoClassRegex = /(:(?!not|global|local)[^\\s\\+>~\\.\\[:]+)/g,\n\t\telementRegex = /([^\\s\\+>~\\.\\[:]+)/g;\n\n\t// Find matches for a regular expression in a string and push their details to parts\n\t// Type is \"a\" for IDs, \"b\" for classes, attributes and pseudo-classes and \"c\" for elements and pseudo-elements\n\tfindMatch = function(regex, type) {\n\t\tvar matches, i, len, match, index, length;\n\t\tif (regex.test(selector)) {\n\t\t\tmatches = selector.match(regex);\n\t\t\tfor (i = 0, len = matches.length; i < len; i += 1) {\n\t\t\t\ttypeCount[type] += 1;\n\t\t\t\tmatch = matches[i];\n\t\t\t\tindex = selector.indexOf(match);\n\t\t\t\tlength = match.length;\n\t\t\t\tparts.push({\n\t\t\t\t\tselector: input.substr(index, length),\n\t\t\t\t\ttype: type,\n\t\t\t\t\tindex: index,\n\t\t\t\t\tlength: length\n\t\t\t\t});\n\t\t\t\t// Replace this simple selector with whitespace so it won't be counted in further simple selectors\n\t\t\t\tselector = selector.replace(match, Array(length + 1).join(' '));\n\t\t\t}\n\t\t}\n\t};\n\n\t// Replace escaped characters with plain text, using the \"A\" character\n\t// https://www.w3.org/TR/CSS21/syndata.html#characters\n\t(function() {\n\t\tvar replaceWithPlainText = function(regex) {\n\t\t\t\tvar matches, i, len, match;\n\t\t\t\tif (regex.test(selector)) {\n\t\t\t\t\tmatches = selector.match(regex);\n\t\t\t\t\tfor (i = 0, len = matches.length; i < len; i += 1) {\n\t\t\t\t\t\tmatch = matches[i];\n\t\t\t\t\t\tselector = selector.replace(match, Array(match.length + 1).join('A'));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t// Matches a backslash followed by six hexadecimal digits followed by an optional single whitespace character\n\t\t\tescapeHexadecimalRegex = /\\\\[0-9A-Fa-f]{6}\\s?/g,\n\t\t\t// Matches a backslash followed by fewer than six hexadecimal digits followed by a mandatory single whitespace character\n\t\t\tescapeHexadecimalRegex2 = /\\\\[0-9A-Fa-f]{1,5}\\s/g,\n\t\t\t// Matches a backslash followed by any character\n\t\t\tescapeSpecialCharacter = /\\\\./g;\n\n\t\treplaceWithPlainText(escapeHexadecimalRegex);\n\t\treplaceWithPlainText(escapeHexadecimalRegex2);\n\t\treplaceWithPlainText(escapeSpecialCharacter);\n\t}());\n\n\t// Remove anything after a left brace in case a user has pasted in a rule, not just a selector\n\t(function() {\n\t\tvar regex = /{[^]*/gm,\n\t\t\tmatches, i, len, match;\n\t\tif (regex.test(selector)) {\n\t\t\tmatches = selector.match(regex);\n\t\t\tfor (i = 0, len = matches.length; i < len; i += 1) {\n\t\t\t\tmatch = matches[i];\n\t\t\t\tselector = selector.replace(match, Array(match.length + 1).join(' '));\n\t\t\t}\n\t\t}\n\t}());\n\n\t// Add attribute selectors to parts collection (type b)\n\tfindMatch(attributeRegex, 'b');\n\n\t// Add ID selectors to parts collection (type a)\n\tfindMatch(idRegex, 'a');\n\n\t// Add class selectors to parts collection (type b)\n\tfindMatch(classRegex, 'b');\n\n\t// Add pseudo-element selectors to parts collection (type c)\n\tfindMatch(pseudoElementRegex, 'c');\n\n\t// Add pseudo-class selectors to parts collection (type b)\n\tfindMatch(pseudoClassWithBracketsRegex, 'b');\n\tfindMatch(pseudoClassRegex, 'b');\n\n\t// Remove universal selector and separator characters\n\tselector = selector.replace(/[\\*\\s\\+>~]/g, ' ');\n\n\t// Remove any stray dots or hashes which aren't attached to words\n\t// These may be present if the user is live-editing this selector\n\tselector = selector.replace(/[#\\.]/g, ' ');\n\n\t// Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument\n \t// Remove non-standard :local and :global CSS Module identifiers because they do not effect the specificity\n\tselector = selector.replace(/:not/g, '    ');\n\tselector = selector.replace(/:local/g, '      ');\n\tselector = selector.replace(/:global/g, '       ');\n\tselector = selector.replace(/[\\(\\)]/g, ' ');\n\n\t// The only things left should be element selectors (type c)\n\tfindMatch(elementRegex, 'c');\n\n\t// Order the parts in the order they appear in the original selector\n\t// This is neater for external apps to deal with\n\tparts.sort(function(a, b) {\n\t\treturn a.index - b.index;\n\t});\n\n\treturn {\n\t\tselector: input,\n\t\tspecificity: '0,' + typeCount.a.toString() + ',' + typeCount.b.toString() + ',' + typeCount.c.toString(),\n\t\tspecificityArray: [0, typeCount.a, typeCount.b, typeCount.c],\n\t\tparts: parts\n\t};\n};\n\n/**\n * Compares two CSS selectors for specificity\n * Alternatively you can replace one of the CSS selectors with a specificity array\n *\n *  - it returns -1 if a has a lower specificity than b\n *  - it returns 1 if a has a higher specificity than b\n *  - it returns 0 if a has the same specificity than b\n */\nvar compare = function(a, b) {\n\tvar aSpecificity,\n\t\tbSpecificity,\n\t\ti;\n\n\tif (typeof a ==='string') {\n\t\tif (a.indexOf(',') !== -1) {\n\t\t\tthrow 'Invalid CSS selector';\n\t\t} else {\n\t\t\taSpecificity = calculateSingle(a)['specificityArray'];\n\t\t}\n\t} else if (Array.isArray(a)) {\n\t\tif (a.filter(function(e) { return (typeof e === 'number'); }).length !== 4) {\n\t\t\tthrow 'Invalid specificity array';\n\t\t} else {\n\t\t\taSpecificity = a;\n\t\t}\n\t} else {\n\t\tthrow 'Invalid CSS selector or specificity array';\n\t}\n\n\tif (typeof b ==='string') {\n\t\tif (b.indexOf(',') !== -1) {\n\t\t\tthrow 'Invalid CSS selector';\n\t\t} else {\n\t\t\tbSpecificity = calculateSingle(b)['specificityArray'];\n\t\t}\n\t} else if (Array.isArray(b)) {\n\t\tif (b.filter(function(e) { return (typeof e === 'number'); }).length !== 4) {\n\t\t\tthrow 'Invalid specificity array';\n\t\t} else {\n\t\t\tbSpecificity = b;\n\t\t}\n\t} else {\n\t\tthrow 'Invalid CSS selector or specificity array';\n\t}\n\n\tfor (i = 0; i < 4; i += 1) {\n\t\tif (aSpecificity[i] < bSpecificity[i]) {\n\t\t\treturn -1;\n\t\t} else if (aSpecificity[i] > bSpecificity[i]) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n};\n\n\n\n\n//# sourceURL=webpack://aperta/./node_modules/specificity/dist/specificity.mjs?");

/***/ }),

/***/ "./node_modules/svelte/index.mjs":
/*!***************************************!*\
  !*** ./node_modules/svelte/index.mjs ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SvelteComponent\": () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.SvelteComponentDev),\n/* harmony export */   \"SvelteComponentTyped\": () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.SvelteComponentTyped),\n/* harmony export */   \"afterUpdate\": () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.afterUpdate),\n/* harmony export */   \"beforeUpdate\": () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.beforeUpdate),\n/* harmony export */   \"createEventDispatcher\": () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.createEventDispatcher),\n/* harmony export */   \"getAllContexts\": () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.getAllContexts),\n/* harmony export */   \"getContext\": () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.getContext),\n/* harmony export */   \"hasContext\": () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.hasContext),\n/* harmony export */   \"onDestroy\": () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.onDestroy),\n/* harmony export */   \"onMount\": () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.onMount),\n/* harmony export */   \"setContext\": () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.setContext),\n/* harmony export */   \"tick\": () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.tick)\n/* harmony export */ });\n/* harmony import */ var _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/index.mjs */ \"./node_modules/svelte/internal/index.mjs\");\n\n\n\n//# sourceURL=webpack://aperta/./node_modules/svelte/index.mjs?");

/***/ }),

/***/ "./node_modules/svelte/internal/index.mjs":
/*!************************************************!*\
  !*** ./node_modules/svelte/internal/index.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"HtmlTag\": () => (/* binding */ HtmlTag),\n/* harmony export */   \"HtmlTagHydration\": () => (/* binding */ HtmlTagHydration),\n/* harmony export */   \"SvelteComponent\": () => (/* binding */ SvelteComponent),\n/* harmony export */   \"SvelteComponentDev\": () => (/* binding */ SvelteComponentDev),\n/* harmony export */   \"SvelteComponentTyped\": () => (/* binding */ SvelteComponentTyped),\n/* harmony export */   \"SvelteElement\": () => (/* binding */ SvelteElement),\n/* harmony export */   \"action_destroyer\": () => (/* binding */ action_destroyer),\n/* harmony export */   \"add_attribute\": () => (/* binding */ add_attribute),\n/* harmony export */   \"add_classes\": () => (/* binding */ add_classes),\n/* harmony export */   \"add_flush_callback\": () => (/* binding */ add_flush_callback),\n/* harmony export */   \"add_location\": () => (/* binding */ add_location),\n/* harmony export */   \"add_render_callback\": () => (/* binding */ add_render_callback),\n/* harmony export */   \"add_resize_listener\": () => (/* binding */ add_resize_listener),\n/* harmony export */   \"add_styles\": () => (/* binding */ add_styles),\n/* harmony export */   \"add_transform\": () => (/* binding */ add_transform),\n/* harmony export */   \"afterUpdate\": () => (/* binding */ afterUpdate),\n/* harmony export */   \"append\": () => (/* binding */ append),\n/* harmony export */   \"append_dev\": () => (/* binding */ append_dev),\n/* harmony export */   \"append_empty_stylesheet\": () => (/* binding */ append_empty_stylesheet),\n/* harmony export */   \"append_hydration\": () => (/* binding */ append_hydration),\n/* harmony export */   \"append_hydration_dev\": () => (/* binding */ append_hydration_dev),\n/* harmony export */   \"append_styles\": () => (/* binding */ append_styles),\n/* harmony export */   \"assign\": () => (/* binding */ assign),\n/* harmony export */   \"attr\": () => (/* binding */ attr),\n/* harmony export */   \"attr_dev\": () => (/* binding */ attr_dev),\n/* harmony export */   \"attribute_to_object\": () => (/* binding */ attribute_to_object),\n/* harmony export */   \"beforeUpdate\": () => (/* binding */ beforeUpdate),\n/* harmony export */   \"bind\": () => (/* binding */ bind),\n/* harmony export */   \"binding_callbacks\": () => (/* binding */ binding_callbacks),\n/* harmony export */   \"blank_object\": () => (/* binding */ blank_object),\n/* harmony export */   \"bubble\": () => (/* binding */ bubble),\n/* harmony export */   \"check_outros\": () => (/* binding */ check_outros),\n/* harmony export */   \"children\": () => (/* binding */ children),\n/* harmony export */   \"claim_comment\": () => (/* binding */ claim_comment),\n/* harmony export */   \"claim_component\": () => (/* binding */ claim_component),\n/* harmony export */   \"claim_element\": () => (/* binding */ claim_element),\n/* harmony export */   \"claim_html_tag\": () => (/* binding */ claim_html_tag),\n/* harmony export */   \"claim_space\": () => (/* binding */ claim_space),\n/* harmony export */   \"claim_svg_element\": () => (/* binding */ claim_svg_element),\n/* harmony export */   \"claim_text\": () => (/* binding */ claim_text),\n/* harmony export */   \"clear_loops\": () => (/* binding */ clear_loops),\n/* harmony export */   \"comment\": () => (/* binding */ comment),\n/* harmony export */   \"component_subscribe\": () => (/* binding */ component_subscribe),\n/* harmony export */   \"compute_rest_props\": () => (/* binding */ compute_rest_props),\n/* harmony export */   \"compute_slots\": () => (/* binding */ compute_slots),\n/* harmony export */   \"construct_svelte_component\": () => (/* binding */ construct_svelte_component),\n/* harmony export */   \"construct_svelte_component_dev\": () => (/* binding */ construct_svelte_component_dev),\n/* harmony export */   \"contenteditable_truthy_values\": () => (/* binding */ contenteditable_truthy_values),\n/* harmony export */   \"createEventDispatcher\": () => (/* binding */ createEventDispatcher),\n/* harmony export */   \"create_animation\": () => (/* binding */ create_animation),\n/* harmony export */   \"create_bidirectional_transition\": () => (/* binding */ create_bidirectional_transition),\n/* harmony export */   \"create_component\": () => (/* binding */ create_component),\n/* harmony export */   \"create_in_transition\": () => (/* binding */ create_in_transition),\n/* harmony export */   \"create_out_transition\": () => (/* binding */ create_out_transition),\n/* harmony export */   \"create_slot\": () => (/* binding */ create_slot),\n/* harmony export */   \"create_ssr_component\": () => (/* binding */ create_ssr_component),\n/* harmony export */   \"current_component\": () => (/* binding */ current_component),\n/* harmony export */   \"custom_event\": () => (/* binding */ custom_event),\n/* harmony export */   \"dataset_dev\": () => (/* binding */ dataset_dev),\n/* harmony export */   \"debug\": () => (/* binding */ debug),\n/* harmony export */   \"destroy_block\": () => (/* binding */ destroy_block),\n/* harmony export */   \"destroy_component\": () => (/* binding */ destroy_component),\n/* harmony export */   \"destroy_each\": () => (/* binding */ destroy_each),\n/* harmony export */   \"detach\": () => (/* binding */ detach),\n/* harmony export */   \"detach_after_dev\": () => (/* binding */ detach_after_dev),\n/* harmony export */   \"detach_before_dev\": () => (/* binding */ detach_before_dev),\n/* harmony export */   \"detach_between_dev\": () => (/* binding */ detach_between_dev),\n/* harmony export */   \"detach_dev\": () => (/* binding */ detach_dev),\n/* harmony export */   \"dirty_components\": () => (/* binding */ dirty_components),\n/* harmony export */   \"dispatch_dev\": () => (/* binding */ dispatch_dev),\n/* harmony export */   \"each\": () => (/* binding */ each),\n/* harmony export */   \"element\": () => (/* binding */ element),\n/* harmony export */   \"element_is\": () => (/* binding */ element_is),\n/* harmony export */   \"empty\": () => (/* binding */ empty),\n/* harmony export */   \"end_hydrating\": () => (/* binding */ end_hydrating),\n/* harmony export */   \"escape\": () => (/* binding */ escape),\n/* harmony export */   \"escape_attribute_value\": () => (/* binding */ escape_attribute_value),\n/* harmony export */   \"escape_object\": () => (/* binding */ escape_object),\n/* harmony export */   \"exclude_internal_props\": () => (/* binding */ exclude_internal_props),\n/* harmony export */   \"fix_and_destroy_block\": () => (/* binding */ fix_and_destroy_block),\n/* harmony export */   \"fix_and_outro_and_destroy_block\": () => (/* binding */ fix_and_outro_and_destroy_block),\n/* harmony export */   \"fix_position\": () => (/* binding */ fix_position),\n/* harmony export */   \"flush\": () => (/* binding */ flush),\n/* harmony export */   \"flush_render_callbacks\": () => (/* binding */ flush_render_callbacks),\n/* harmony export */   \"getAllContexts\": () => (/* binding */ getAllContexts),\n/* harmony export */   \"getContext\": () => (/* binding */ getContext),\n/* harmony export */   \"get_all_dirty_from_scope\": () => (/* binding */ get_all_dirty_from_scope),\n/* harmony export */   \"get_binding_group_value\": () => (/* binding */ get_binding_group_value),\n/* harmony export */   \"get_current_component\": () => (/* binding */ get_current_component),\n/* harmony export */   \"get_custom_elements_slots\": () => (/* binding */ get_custom_elements_slots),\n/* harmony export */   \"get_root_for_style\": () => (/* binding */ get_root_for_style),\n/* harmony export */   \"get_slot_changes\": () => (/* binding */ get_slot_changes),\n/* harmony export */   \"get_spread_object\": () => (/* binding */ get_spread_object),\n/* harmony export */   \"get_spread_update\": () => (/* binding */ get_spread_update),\n/* harmony export */   \"get_store_value\": () => (/* binding */ get_store_value),\n/* harmony export */   \"globals\": () => (/* binding */ globals),\n/* harmony export */   \"group_outros\": () => (/* binding */ group_outros),\n/* harmony export */   \"handle_promise\": () => (/* binding */ handle_promise),\n/* harmony export */   \"hasContext\": () => (/* binding */ hasContext),\n/* harmony export */   \"has_prop\": () => (/* binding */ has_prop),\n/* harmony export */   \"head_selector\": () => (/* binding */ head_selector),\n/* harmony export */   \"identity\": () => (/* binding */ identity),\n/* harmony export */   \"init\": () => (/* binding */ init),\n/* harmony export */   \"init_binding_group\": () => (/* binding */ init_binding_group),\n/* harmony export */   \"init_binding_group_dynamic\": () => (/* binding */ init_binding_group_dynamic),\n/* harmony export */   \"insert\": () => (/* binding */ insert),\n/* harmony export */   \"insert_dev\": () => (/* binding */ insert_dev),\n/* harmony export */   \"insert_hydration\": () => (/* binding */ insert_hydration),\n/* harmony export */   \"insert_hydration_dev\": () => (/* binding */ insert_hydration_dev),\n/* harmony export */   \"intros\": () => (/* binding */ intros),\n/* harmony export */   \"invalid_attribute_name_character\": () => (/* binding */ invalid_attribute_name_character),\n/* harmony export */   \"is_client\": () => (/* binding */ is_client),\n/* harmony export */   \"is_crossorigin\": () => (/* binding */ is_crossorigin),\n/* harmony export */   \"is_empty\": () => (/* binding */ is_empty),\n/* harmony export */   \"is_function\": () => (/* binding */ is_function),\n/* harmony export */   \"is_promise\": () => (/* binding */ is_promise),\n/* harmony export */   \"is_void\": () => (/* binding */ is_void),\n/* harmony export */   \"listen\": () => (/* binding */ listen),\n/* harmony export */   \"listen_dev\": () => (/* binding */ listen_dev),\n/* harmony export */   \"loop\": () => (/* binding */ loop),\n/* harmony export */   \"loop_guard\": () => (/* binding */ loop_guard),\n/* harmony export */   \"merge_ssr_styles\": () => (/* binding */ merge_ssr_styles),\n/* harmony export */   \"missing_component\": () => (/* binding */ missing_component),\n/* harmony export */   \"mount_component\": () => (/* binding */ mount_component),\n/* harmony export */   \"noop\": () => (/* binding */ noop),\n/* harmony export */   \"not_equal\": () => (/* binding */ not_equal),\n/* harmony export */   \"now\": () => (/* binding */ now),\n/* harmony export */   \"null_to_empty\": () => (/* binding */ null_to_empty),\n/* harmony export */   \"object_without_properties\": () => (/* binding */ object_without_properties),\n/* harmony export */   \"onDestroy\": () => (/* binding */ onDestroy),\n/* harmony export */   \"onMount\": () => (/* binding */ onMount),\n/* harmony export */   \"once\": () => (/* binding */ once),\n/* harmony export */   \"outro_and_destroy_block\": () => (/* binding */ outro_and_destroy_block),\n/* harmony export */   \"prevent_default\": () => (/* binding */ prevent_default),\n/* harmony export */   \"prop_dev\": () => (/* binding */ prop_dev),\n/* harmony export */   \"query_selector_all\": () => (/* binding */ query_selector_all),\n/* harmony export */   \"raf\": () => (/* binding */ raf),\n/* harmony export */   \"run\": () => (/* binding */ run),\n/* harmony export */   \"run_all\": () => (/* binding */ run_all),\n/* harmony export */   \"safe_not_equal\": () => (/* binding */ safe_not_equal),\n/* harmony export */   \"schedule_update\": () => (/* binding */ schedule_update),\n/* harmony export */   \"select_multiple_value\": () => (/* binding */ select_multiple_value),\n/* harmony export */   \"select_option\": () => (/* binding */ select_option),\n/* harmony export */   \"select_options\": () => (/* binding */ select_options),\n/* harmony export */   \"select_value\": () => (/* binding */ select_value),\n/* harmony export */   \"self\": () => (/* binding */ self),\n/* harmony export */   \"setContext\": () => (/* binding */ setContext),\n/* harmony export */   \"set_attributes\": () => (/* binding */ set_attributes),\n/* harmony export */   \"set_current_component\": () => (/* binding */ set_current_component),\n/* harmony export */   \"set_custom_element_data\": () => (/* binding */ set_custom_element_data),\n/* harmony export */   \"set_custom_element_data_map\": () => (/* binding */ set_custom_element_data_map),\n/* harmony export */   \"set_data\": () => (/* binding */ set_data),\n/* harmony export */   \"set_data_contenteditable\": () => (/* binding */ set_data_contenteditable),\n/* harmony export */   \"set_data_contenteditable_dev\": () => (/* binding */ set_data_contenteditable_dev),\n/* harmony export */   \"set_data_dev\": () => (/* binding */ set_data_dev),\n/* harmony export */   \"set_data_maybe_contenteditable\": () => (/* binding */ set_data_maybe_contenteditable),\n/* harmony export */   \"set_data_maybe_contenteditable_dev\": () => (/* binding */ set_data_maybe_contenteditable_dev),\n/* harmony export */   \"set_dynamic_element_data\": () => (/* binding */ set_dynamic_element_data),\n/* harmony export */   \"set_input_type\": () => (/* binding */ set_input_type),\n/* harmony export */   \"set_input_value\": () => (/* binding */ set_input_value),\n/* harmony export */   \"set_now\": () => (/* binding */ set_now),\n/* harmony export */   \"set_raf\": () => (/* binding */ set_raf),\n/* harmony export */   \"set_store_value\": () => (/* binding */ set_store_value),\n/* harmony export */   \"set_style\": () => (/* binding */ set_style),\n/* harmony export */   \"set_svg_attributes\": () => (/* binding */ set_svg_attributes),\n/* harmony export */   \"space\": () => (/* binding */ space),\n/* harmony export */   \"split_css_unit\": () => (/* binding */ split_css_unit),\n/* harmony export */   \"spread\": () => (/* binding */ spread),\n/* harmony export */   \"src_url_equal\": () => (/* binding */ src_url_equal),\n/* harmony export */   \"start_hydrating\": () => (/* binding */ start_hydrating),\n/* harmony export */   \"stop_immediate_propagation\": () => (/* binding */ stop_immediate_propagation),\n/* harmony export */   \"stop_propagation\": () => (/* binding */ stop_propagation),\n/* harmony export */   \"subscribe\": () => (/* binding */ subscribe),\n/* harmony export */   \"svg_element\": () => (/* binding */ svg_element),\n/* harmony export */   \"text\": () => (/* binding */ text),\n/* harmony export */   \"tick\": () => (/* binding */ tick),\n/* harmony export */   \"time_ranges_to_array\": () => (/* binding */ time_ranges_to_array),\n/* harmony export */   \"to_number\": () => (/* binding */ to_number),\n/* harmony export */   \"toggle_class\": () => (/* binding */ toggle_class),\n/* harmony export */   \"transition_in\": () => (/* binding */ transition_in),\n/* harmony export */   \"transition_out\": () => (/* binding */ transition_out),\n/* harmony export */   \"trusted\": () => (/* binding */ trusted),\n/* harmony export */   \"update_await_block_branch\": () => (/* binding */ update_await_block_branch),\n/* harmony export */   \"update_keyed_each\": () => (/* binding */ update_keyed_each),\n/* harmony export */   \"update_slot\": () => (/* binding */ update_slot),\n/* harmony export */   \"update_slot_base\": () => (/* binding */ update_slot_base),\n/* harmony export */   \"validate_component\": () => (/* binding */ validate_component),\n/* harmony export */   \"validate_dynamic_element\": () => (/* binding */ validate_dynamic_element),\n/* harmony export */   \"validate_each_argument\": () => (/* binding */ validate_each_argument),\n/* harmony export */   \"validate_each_keys\": () => (/* binding */ validate_each_keys),\n/* harmony export */   \"validate_slots\": () => (/* binding */ validate_slots),\n/* harmony export */   \"validate_store\": () => (/* binding */ validate_store),\n/* harmony export */   \"validate_void_dynamic_element\": () => (/* binding */ validate_void_dynamic_element),\n/* harmony export */   \"xlink_attr\": () => (/* binding */ xlink_attr)\n/* harmony export */ });\nfunction noop() { }\nconst identity = x => x;\nfunction assign(tar, src) {\n    // @ts-ignore\n    for (const k in src)\n        tar[k] = src[k];\n    return tar;\n}\n// Adapted from https://github.com/then/is-promise/blob/master/index.js\n// Distributed under MIT License https://github.com/then/is-promise/blob/master/LICENSE\nfunction is_promise(value) {\n    return !!value && (typeof value === 'object' || typeof value === 'function') && typeof value.then === 'function';\n}\nfunction add_location(element, file, line, column, char) {\n    element.__svelte_meta = {\n        loc: { file, line, column, char }\n    };\n}\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\nfunction is_function(thing) {\n    return typeof thing === 'function';\n}\nfunction safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n}\nlet src_url_equal_anchor;\nfunction src_url_equal(element_src, url) {\n    if (!src_url_equal_anchor) {\n        src_url_equal_anchor = document.createElement('a');\n    }\n    src_url_equal_anchor.href = url;\n    return element_src === src_url_equal_anchor.href;\n}\nfunction not_equal(a, b) {\n    return a != a ? b == b : a !== b;\n}\nfunction is_empty(obj) {\n    return Object.keys(obj).length === 0;\n}\nfunction validate_store(store, name) {\n    if (store != null && typeof store.subscribe !== 'function') {\n        throw new Error(`'${name}' is not a store with a 'subscribe' method`);\n    }\n}\nfunction subscribe(store, ...callbacks) {\n    if (store == null) {\n        return noop;\n    }\n    const unsub = store.subscribe(...callbacks);\n    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\nfunction get_store_value(store) {\n    let value;\n    subscribe(store, _ => value = _)();\n    return value;\n}\nfunction component_subscribe(component, store, callback) {\n    component.$$.on_destroy.push(subscribe(store, callback));\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n    if (definition) {\n        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n        return definition[0](slot_ctx);\n    }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n    return definition[1] && fn\n        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))\n        : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n    if (definition[2] && fn) {\n        const lets = definition[2](fn(dirty));\n        if ($$scope.dirty === undefined) {\n            return lets;\n        }\n        if (typeof lets === 'object') {\n            const merged = [];\n            const len = Math.max($$scope.dirty.length, lets.length);\n            for (let i = 0; i < len; i += 1) {\n                merged[i] = $$scope.dirty[i] | lets[i];\n            }\n            return merged;\n        }\n        return $$scope.dirty | lets;\n    }\n    return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n    if (slot_changes) {\n        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n        slot.p(slot_context, slot_changes);\n    }\n}\nfunction update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {\n    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n    update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);\n}\nfunction get_all_dirty_from_scope($$scope) {\n    if ($$scope.ctx.length > 32) {\n        const dirty = [];\n        const length = $$scope.ctx.length / 32;\n        for (let i = 0; i < length; i++) {\n            dirty[i] = -1;\n        }\n        return dirty;\n    }\n    return -1;\n}\nfunction exclude_internal_props(props) {\n    const result = {};\n    for (const k in props)\n        if (k[0] !== '$')\n            result[k] = props[k];\n    return result;\n}\nfunction compute_rest_props(props, keys) {\n    const rest = {};\n    keys = new Set(keys);\n    for (const k in props)\n        if (!keys.has(k) && k[0] !== '$')\n            rest[k] = props[k];\n    return rest;\n}\nfunction compute_slots(slots) {\n    const result = {};\n    for (const key in slots) {\n        result[key] = true;\n    }\n    return result;\n}\nfunction once(fn) {\n    let ran = false;\n    return function (...args) {\n        if (ran)\n            return;\n        ran = true;\n        fn.call(this, ...args);\n    };\n}\nfunction null_to_empty(value) {\n    return value == null ? '' : value;\n}\nfunction set_store_value(store, ret, value) {\n    store.set(value);\n    return ret;\n}\nconst has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nfunction action_destroyer(action_result) {\n    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\nfunction split_css_unit(value) {\n    const split = typeof value === 'string' && value.match(/^\\s*(-?[\\d.]+)([^\\s]*)\\s*$/);\n    return split ? [parseFloat(split[1]), split[2] || 'px'] : [value, 'px'];\n}\nconst contenteditable_truthy_values = ['', true, 1, 'true', 'contenteditable'];\n\nconst is_client = typeof window !== 'undefined';\nlet now = is_client\n    ? () => window.performance.now()\n    : () => Date.now();\nlet raf = is_client ? cb => requestAnimationFrame(cb) : noop;\n// used internally for testing\nfunction set_now(fn) {\n    now = fn;\n}\nfunction set_raf(fn) {\n    raf = fn;\n}\n\nconst tasks = new Set();\nfunction run_tasks(now) {\n    tasks.forEach(task => {\n        if (!task.c(now)) {\n            tasks.delete(task);\n            task.f();\n        }\n    });\n    if (tasks.size !== 0)\n        raf(run_tasks);\n}\n/**\n * For testing purposes only!\n */\nfunction clear_loops() {\n    tasks.clear();\n}\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n */\nfunction loop(callback) {\n    let task;\n    if (tasks.size === 0)\n        raf(run_tasks);\n    return {\n        promise: new Promise(fulfill => {\n            tasks.add(task = { c: callback, f: fulfill });\n        }),\n        abort() {\n            tasks.delete(task);\n        }\n    };\n}\n\n// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n// at the end of hydration without touching the remaining nodes.\nlet is_hydrating = false;\nfunction start_hydrating() {\n    is_hydrating = true;\n}\nfunction end_hydrating() {\n    is_hydrating = false;\n}\nfunction upper_bound(low, high, key, value) {\n    // Return first index of value larger than input value in the range [low, high)\n    while (low < high) {\n        const mid = low + ((high - low) >> 1);\n        if (key(mid) <= value) {\n            low = mid + 1;\n        }\n        else {\n            high = mid;\n        }\n    }\n    return low;\n}\nfunction init_hydrate(target) {\n    if (target.hydrate_init)\n        return;\n    target.hydrate_init = true;\n    // We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\n    let children = target.childNodes;\n    // If target is <head>, there may be children without claim_order\n    if (target.nodeName === 'HEAD') {\n        const myChildren = [];\n        for (let i = 0; i < children.length; i++) {\n            const node = children[i];\n            if (node.claim_order !== undefined) {\n                myChildren.push(node);\n            }\n        }\n        children = myChildren;\n    }\n    /*\n    * Reorder claimed children optimally.\n    * We can reorder claimed children optimally by finding the longest subsequence of\n    * nodes that are already claimed in order and only moving the rest. The longest\n    * subsequence of nodes that are claimed in order can be found by\n    * computing the longest increasing subsequence of .claim_order values.\n    *\n    * This algorithm is optimal in generating the least amount of reorder operations\n    * possible.\n    *\n    * Proof:\n    * We know that, given a set of reordering operations, the nodes that do not move\n    * always form an increasing subsequence, since they do not move among each other\n    * meaning that they must be already ordered among each other. Thus, the maximal\n    * set of nodes that do not move form a longest increasing subsequence.\n    */\n    // Compute longest increasing subsequence\n    // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n    const m = new Int32Array(children.length + 1);\n    // Predecessor indices + 1\n    const p = new Int32Array(children.length);\n    m[0] = -1;\n    let longest = 0;\n    for (let i = 0; i < children.length; i++) {\n        const current = children[i].claim_order;\n        // Find the largest subsequence length such that it ends in a value less than our current value\n        // upper_bound returns first greater value, so we subtract one\n        // with fast path for when we are on the current longest subsequence\n        const seqLen = ((longest > 0 && children[m[longest]].claim_order <= current) ? longest + 1 : upper_bound(1, longest, idx => children[m[idx]].claim_order, current)) - 1;\n        p[i] = m[seqLen] + 1;\n        const newLen = seqLen + 1;\n        // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n        m[newLen] = i;\n        longest = Math.max(newLen, longest);\n    }\n    // The longest increasing subsequence of nodes (initially reversed)\n    const lis = [];\n    // The rest of the nodes, nodes that will be moved\n    const toMove = [];\n    let last = children.length - 1;\n    for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n        lis.push(children[cur - 1]);\n        for (; last >= cur; last--) {\n            toMove.push(children[last]);\n        }\n        last--;\n    }\n    for (; last >= 0; last--) {\n        toMove.push(children[last]);\n    }\n    lis.reverse();\n    // We sort the nodes being moved to guarantee that their insertion order matches the claim order\n    toMove.sort((a, b) => a.claim_order - b.claim_order);\n    // Finally, we move the nodes\n    for (let i = 0, j = 0; i < toMove.length; i++) {\n        while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {\n            j++;\n        }\n        const anchor = j < lis.length ? lis[j] : null;\n        target.insertBefore(toMove[i], anchor);\n    }\n}\nfunction append(target, node) {\n    target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n    const append_styles_to = get_root_for_style(target);\n    if (!append_styles_to.getElementById(style_sheet_id)) {\n        const style = element('style');\n        style.id = style_sheet_id;\n        style.textContent = styles;\n        append_stylesheet(append_styles_to, style);\n    }\n}\nfunction get_root_for_style(node) {\n    if (!node)\n        return document;\n    const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n    if (root && root.host) {\n        return root;\n    }\n    return node.ownerDocument;\n}\nfunction append_empty_stylesheet(node) {\n    const style_element = element('style');\n    append_stylesheet(get_root_for_style(node), style_element);\n    return style_element.sheet;\n}\nfunction append_stylesheet(node, style) {\n    append(node.head || node, style);\n    return style.sheet;\n}\nfunction append_hydration(target, node) {\n    if (is_hydrating) {\n        init_hydrate(target);\n        if ((target.actual_end_child === undefined) || ((target.actual_end_child !== null) && (target.actual_end_child.parentNode !== target))) {\n            target.actual_end_child = target.firstChild;\n        }\n        // Skip nodes of undefined ordering\n        while ((target.actual_end_child !== null) && (target.actual_end_child.claim_order === undefined)) {\n            target.actual_end_child = target.actual_end_child.nextSibling;\n        }\n        if (node !== target.actual_end_child) {\n            // We only insert if the ordering of this node should be modified or the parent node is not target\n            if (node.claim_order !== undefined || node.parentNode !== target) {\n                target.insertBefore(node, target.actual_end_child);\n            }\n        }\n        else {\n            target.actual_end_child = node.nextSibling;\n        }\n    }\n    else if (node.parentNode !== target || node.nextSibling !== null) {\n        target.appendChild(node);\n    }\n}\nfunction insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n}\nfunction insert_hydration(target, node, anchor) {\n    if (is_hydrating && !anchor) {\n        append_hydration(target, node);\n    }\n    else if (node.parentNode !== target || node.nextSibling != anchor) {\n        target.insertBefore(node, anchor || null);\n    }\n}\nfunction detach(node) {\n    if (node.parentNode) {\n        node.parentNode.removeChild(node);\n    }\n}\nfunction destroy_each(iterations, detaching) {\n    for (let i = 0; i < iterations.length; i += 1) {\n        if (iterations[i])\n            iterations[i].d(detaching);\n    }\n}\nfunction element(name) {\n    return document.createElement(name);\n}\nfunction element_is(name, is) {\n    return document.createElement(name, { is });\n}\nfunction object_without_properties(obj, exclude) {\n    const target = {};\n    for (const k in obj) {\n        if (has_prop(obj, k)\n            // @ts-ignore\n            && exclude.indexOf(k) === -1) {\n            // @ts-ignore\n            target[k] = obj[k];\n        }\n    }\n    return target;\n}\nfunction svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\nfunction text(data) {\n    return document.createTextNode(data);\n}\nfunction space() {\n    return text(' ');\n}\nfunction empty() {\n    return text('');\n}\nfunction comment(content) {\n    return document.createComment(content);\n}\nfunction listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return () => node.removeEventListener(event, handler, options);\n}\nfunction prevent_default(fn) {\n    return function (event) {\n        event.preventDefault();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_propagation(fn) {\n    return function (event) {\n        event.stopPropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_immediate_propagation(fn) {\n    return function (event) {\n        event.stopImmediatePropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction self(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.target === this)\n            fn.call(this, event);\n    };\n}\nfunction trusted(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.isTrusted)\n            fn.call(this, event);\n    };\n}\nfunction attr(node, attribute, value) {\n    if (value == null)\n        node.removeAttribute(attribute);\n    else if (node.getAttribute(attribute) !== value)\n        node.setAttribute(attribute, value);\n}\nfunction set_attributes(node, attributes) {\n    // @ts-ignore\n    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (const key in attributes) {\n        if (attributes[key] == null) {\n            node.removeAttribute(key);\n        }\n        else if (key === 'style') {\n            node.style.cssText = attributes[key];\n        }\n        else if (key === '__value') {\n            node.value = node[key] = attributes[key];\n        }\n        else if (descriptors[key] && descriptors[key].set) {\n            node[key] = attributes[key];\n        }\n        else {\n            attr(node, key, attributes[key]);\n        }\n    }\n}\nfunction set_svg_attributes(node, attributes) {\n    for (const key in attributes) {\n        attr(node, key, attributes[key]);\n    }\n}\nfunction set_custom_element_data_map(node, data_map) {\n    Object.keys(data_map).forEach((key) => {\n        set_custom_element_data(node, key, data_map[key]);\n    });\n}\nfunction set_custom_element_data(node, prop, value) {\n    if (prop in node) {\n        node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;\n    }\n    else {\n        attr(node, prop, value);\n    }\n}\nfunction set_dynamic_element_data(tag) {\n    return (/-/.test(tag)) ? set_custom_element_data_map : set_attributes;\n}\nfunction xlink_attr(node, attribute, value) {\n    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\nfunction get_binding_group_value(group, __value, checked) {\n    const value = new Set();\n    for (let i = 0; i < group.length; i += 1) {\n        if (group[i].checked)\n            value.add(group[i].__value);\n    }\n    if (!checked) {\n        value.delete(__value);\n    }\n    return Array.from(value);\n}\nfunction init_binding_group(group) {\n    let _inputs;\n    return {\n        /* push */ p(...inputs) {\n            _inputs = inputs;\n            _inputs.forEach(input => group.push(input));\n        },\n        /* remove */ r() {\n            _inputs.forEach(input => group.splice(group.indexOf(input), 1));\n        }\n    };\n}\nfunction init_binding_group_dynamic(group, indexes) {\n    let _group = get_binding_group(group);\n    let _inputs;\n    function get_binding_group(group) {\n        for (let i = 0; i < indexes.length; i++) {\n            group = group[indexes[i]] = group[indexes[i]] || [];\n        }\n        return group;\n    }\n    function push() {\n        _inputs.forEach(input => _group.push(input));\n    }\n    function remove() {\n        _inputs.forEach(input => _group.splice(_group.indexOf(input), 1));\n    }\n    return {\n        /* update */ u(new_indexes) {\n            indexes = new_indexes;\n            const new_group = get_binding_group(group);\n            if (new_group !== _group) {\n                remove();\n                _group = new_group;\n                push();\n            }\n        },\n        /* push */ p(...inputs) {\n            _inputs = inputs;\n            push();\n        },\n        /* remove */ r: remove\n    };\n}\nfunction to_number(value) {\n    return value === '' ? null : +value;\n}\nfunction time_ranges_to_array(ranges) {\n    const array = [];\n    for (let i = 0; i < ranges.length; i += 1) {\n        array.push({ start: ranges.start(i), end: ranges.end(i) });\n    }\n    return array;\n}\nfunction children(element) {\n    return Array.from(element.childNodes);\n}\nfunction init_claim_info(nodes) {\n    if (nodes.claim_info === undefined) {\n        nodes.claim_info = { last_index: 0, total_claimed: 0 };\n    }\n}\nfunction claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {\n    // Try to find nodes in an order such that we lengthen the longest increasing subsequence\n    init_claim_info(nodes);\n    const resultNode = (() => {\n        // We first try to find an element after the previous one\n        for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                return node;\n            }\n        }\n        // Otherwise, we try to find one before\n        // We iterate in reverse so that we don't go too far back\n        for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                else if (replacement === undefined) {\n                    // Since we spliced before the last_index, we decrease it\n                    nodes.claim_info.last_index--;\n                }\n                return node;\n            }\n        }\n        // If we can't find any matching node, we create a new one\n        return createNode();\n    })();\n    resultNode.claim_order = nodes.claim_info.total_claimed;\n    nodes.claim_info.total_claimed += 1;\n    return resultNode;\n}\nfunction claim_element_base(nodes, name, attributes, create_element) {\n    return claim_node(nodes, (node) => node.nodeName === name, (node) => {\n        const remove = [];\n        for (let j = 0; j < node.attributes.length; j++) {\n            const attribute = node.attributes[j];\n            if (!attributes[attribute.name]) {\n                remove.push(attribute.name);\n            }\n        }\n        remove.forEach(v => node.removeAttribute(v));\n        return undefined;\n    }, () => create_element(name));\n}\nfunction claim_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, element);\n}\nfunction claim_svg_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, svg_element);\n}\nfunction claim_text(nodes, data) {\n    return claim_node(nodes, (node) => node.nodeType === 3, (node) => {\n        const dataStr = '' + data;\n        if (node.data.startsWith(dataStr)) {\n            if (node.data.length !== dataStr.length) {\n                return node.splitText(dataStr.length);\n            }\n        }\n        else {\n            node.data = dataStr;\n        }\n    }, () => text(data), true // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n    );\n}\nfunction claim_space(nodes) {\n    return claim_text(nodes, ' ');\n}\nfunction claim_comment(nodes, data) {\n    return claim_node(nodes, (node) => node.nodeType === 8, (node) => {\n        node.data = '' + data;\n        return undefined;\n    }, () => comment(data), true);\n}\nfunction find_comment(nodes, text, start) {\n    for (let i = start; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {\n            return i;\n        }\n    }\n    return nodes.length;\n}\nfunction claim_html_tag(nodes, is_svg) {\n    // find html opening tag\n    const start_index = find_comment(nodes, 'HTML_TAG_START', 0);\n    const end_index = find_comment(nodes, 'HTML_TAG_END', start_index);\n    if (start_index === end_index) {\n        return new HtmlTagHydration(undefined, is_svg);\n    }\n    init_claim_info(nodes);\n    const html_tag_nodes = nodes.splice(start_index, end_index - start_index + 1);\n    detach(html_tag_nodes[0]);\n    detach(html_tag_nodes[html_tag_nodes.length - 1]);\n    const claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);\n    for (const n of claimed_nodes) {\n        n.claim_order = nodes.claim_info.total_claimed;\n        nodes.claim_info.total_claimed += 1;\n    }\n    return new HtmlTagHydration(claimed_nodes, is_svg);\n}\nfunction set_data(text, data) {\n    data = '' + data;\n    if (text.data === data)\n        return;\n    text.data = data;\n}\nfunction set_data_contenteditable(text, data) {\n    data = '' + data;\n    if (text.wholeText === data)\n        return;\n    text.data = data;\n}\nfunction set_data_maybe_contenteditable(text, data, attr_value) {\n    if (~contenteditable_truthy_values.indexOf(attr_value)) {\n        set_data_contenteditable(text, data);\n    }\n    else {\n        set_data(text, data);\n    }\n}\nfunction set_input_value(input, value) {\n    input.value = value == null ? '' : value;\n}\nfunction set_input_type(input, type) {\n    try {\n        input.type = type;\n    }\n    catch (e) {\n        // do nothing\n    }\n}\nfunction set_style(node, key, value, important) {\n    if (value === null) {\n        node.style.removeProperty(key);\n    }\n    else {\n        node.style.setProperty(key, value, important ? 'important' : '');\n    }\n}\nfunction select_option(select, value, mounting) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        if (option.__value === value) {\n            option.selected = true;\n            return;\n        }\n    }\n    if (!mounting || value !== undefined) {\n        select.selectedIndex = -1; // no option should be selected\n    }\n}\nfunction select_options(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        option.selected = ~value.indexOf(option.__value);\n    }\n}\nfunction select_value(select) {\n    const selected_option = select.querySelector(':checked');\n    return selected_option && selected_option.__value;\n}\nfunction select_multiple_value(select) {\n    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\nlet crossorigin;\nfunction is_crossorigin() {\n    if (crossorigin === undefined) {\n        crossorigin = false;\n        try {\n            if (typeof window !== 'undefined' && window.parent) {\n                void window.parent.document;\n            }\n        }\n        catch (error) {\n            crossorigin = true;\n        }\n    }\n    return crossorigin;\n}\nfunction add_resize_listener(node, fn) {\n    const computed_style = getComputedStyle(node);\n    if (computed_style.position === 'static') {\n        node.style.position = 'relative';\n    }\n    const iframe = element('iframe');\n    iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +\n        'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');\n    iframe.setAttribute('aria-hidden', 'true');\n    iframe.tabIndex = -1;\n    const crossorigin = is_crossorigin();\n    let unsubscribe;\n    if (crossorigin) {\n        iframe.src = \"data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>\";\n        unsubscribe = listen(window, 'message', (event) => {\n            if (event.source === iframe.contentWindow)\n                fn();\n        });\n    }\n    else {\n        iframe.src = 'about:blank';\n        iframe.onload = () => {\n            unsubscribe = listen(iframe.contentWindow, 'resize', fn);\n            // make sure an initial resize event is fired _after_ the iframe is loaded (which is asynchronous)\n            // see https://github.com/sveltejs/svelte/issues/4233\n            fn();\n        };\n    }\n    append(node, iframe);\n    return () => {\n        if (crossorigin) {\n            unsubscribe();\n        }\n        else if (unsubscribe && iframe.contentWindow) {\n            unsubscribe();\n        }\n        detach(iframe);\n    };\n}\nfunction toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n}\nfunction custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {\n    const e = document.createEvent('CustomEvent');\n    e.initCustomEvent(type, bubbles, cancelable, detail);\n    return e;\n}\nfunction query_selector_all(selector, parent = document.body) {\n    return Array.from(parent.querySelectorAll(selector));\n}\nfunction head_selector(nodeId, head) {\n    const result = [];\n    let started = 0;\n    for (const node of head.childNodes) {\n        if (node.nodeType === 8 /* comment node */) {\n            const comment = node.textContent.trim();\n            if (comment === `HEAD_${nodeId}_END`) {\n                started -= 1;\n                result.push(node);\n            }\n            else if (comment === `HEAD_${nodeId}_START`) {\n                started += 1;\n                result.push(node);\n            }\n        }\n        else if (started > 0) {\n            result.push(node);\n        }\n    }\n    return result;\n}\nclass HtmlTag {\n    constructor(is_svg = false) {\n        this.is_svg = false;\n        this.is_svg = is_svg;\n        this.e = this.n = null;\n    }\n    c(html) {\n        this.h(html);\n    }\n    m(html, target, anchor = null) {\n        if (!this.e) {\n            if (this.is_svg)\n                this.e = svg_element(target.nodeName);\n            /** #7364  target for <template> may be provided as #document-fragment(11) */\n            else\n                this.e = element((target.nodeType === 11 ? 'TEMPLATE' : target.nodeName));\n            this.t = target.tagName !== 'TEMPLATE' ? target : target.content;\n            this.c(html);\n        }\n        this.i(anchor);\n    }\n    h(html) {\n        this.e.innerHTML = html;\n        this.n = Array.from(this.e.nodeName === 'TEMPLATE' ? this.e.content.childNodes : this.e.childNodes);\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert(this.t, this.n[i], anchor);\n        }\n    }\n    p(html) {\n        this.d();\n        this.h(html);\n        this.i(this.a);\n    }\n    d() {\n        this.n.forEach(detach);\n    }\n}\nclass HtmlTagHydration extends HtmlTag {\n    constructor(claimed_nodes, is_svg = false) {\n        super(is_svg);\n        this.e = this.n = null;\n        this.l = claimed_nodes;\n    }\n    c(html) {\n        if (this.l) {\n            this.n = this.l;\n        }\n        else {\n            super.c(html);\n        }\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert_hydration(this.t, this.n[i], anchor);\n        }\n    }\n}\nfunction attribute_to_object(attributes) {\n    const result = {};\n    for (const attribute of attributes) {\n        result[attribute.name] = attribute.value;\n    }\n    return result;\n}\nfunction get_custom_elements_slots(element) {\n    const result = {};\n    element.childNodes.forEach((node) => {\n        result[node.slot || 'default'] = true;\n    });\n    return result;\n}\nfunction construct_svelte_component(component, props) {\n    return new component(props);\n}\n\n// we need to store the information for multiple documents because a Svelte application could also contain iframes\n// https://github.com/sveltejs/svelte/issues/3624\nconst managed_styles = new Map();\nlet active = 0;\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str) {\n    let hash = 5381;\n    let i = str.length;\n    while (i--)\n        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n    return hash >>> 0;\n}\nfunction create_style_information(doc, node) {\n    const info = { stylesheet: append_empty_stylesheet(node), rules: {} };\n    managed_styles.set(doc, info);\n    return info;\n}\nfunction create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n    const step = 16.666 / duration;\n    let keyframes = '{\\n';\n    for (let p = 0; p <= 1; p += step) {\n        const t = a + (b - a) * ease(p);\n        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n    }\n    const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n    const name = `__svelte_${hash(rule)}_${uid}`;\n    const doc = get_root_for_style(node);\n    const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);\n    if (!rules[name]) {\n        rules[name] = true;\n        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n    }\n    const animation = node.style.animation || '';\n    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;\n    active += 1;\n    return name;\n}\nfunction delete_rule(node, name) {\n    const previous = (node.style.animation || '').split(', ');\n    const next = previous.filter(name\n        ? anim => anim.indexOf(name) < 0 // remove specific animation\n        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n    );\n    const deleted = previous.length - next.length;\n    if (deleted) {\n        node.style.animation = next.join(', ');\n        active -= deleted;\n        if (!active)\n            clear_rules();\n    }\n}\nfunction clear_rules() {\n    raf(() => {\n        if (active)\n            return;\n        managed_styles.forEach(info => {\n            const { ownerNode } = info.stylesheet;\n            // there is no ownerNode if it runs on jsdom.\n            if (ownerNode)\n                detach(ownerNode);\n        });\n        managed_styles.clear();\n    });\n}\n\nfunction create_animation(node, from, fn, params) {\n    if (!from)\n        return noop;\n    const to = node.getBoundingClientRect();\n    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)\n        return noop;\n    const { delay = 0, duration = 300, easing = identity, \n    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n    start: start_time = now() + delay, \n    // @ts-ignore todo:\n    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);\n    let running = true;\n    let started = false;\n    let name;\n    function start() {\n        if (css) {\n            name = create_rule(node, 0, 1, duration, delay, easing, css);\n        }\n        if (!delay) {\n            started = true;\n        }\n    }\n    function stop() {\n        if (css)\n            delete_rule(node, name);\n        running = false;\n    }\n    loop(now => {\n        if (!started && now >= start_time) {\n            started = true;\n        }\n        if (started && now >= end) {\n            tick(1, 0);\n            stop();\n        }\n        if (!running) {\n            return false;\n        }\n        if (started) {\n            const p = now - start_time;\n            const t = 0 + 1 * easing(p / duration);\n            tick(t, 1 - t);\n        }\n        return true;\n    });\n    start();\n    tick(0, 1);\n    return stop;\n}\nfunction fix_position(node) {\n    const style = getComputedStyle(node);\n    if (style.position !== 'absolute' && style.position !== 'fixed') {\n        const { width, height } = style;\n        const a = node.getBoundingClientRect();\n        node.style.position = 'absolute';\n        node.style.width = width;\n        node.style.height = height;\n        add_transform(node, a);\n    }\n}\nfunction add_transform(node, a) {\n    const b = node.getBoundingClientRect();\n    if (a.left !== b.left || a.top !== b.top) {\n        const style = getComputedStyle(node);\n        const transform = style.transform === 'none' ? '' : style.transform;\n        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n    }\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nfunction get_current_component() {\n    if (!current_component)\n        throw new Error('Function called outside component initialization');\n    return current_component;\n}\n/**\n * Schedules a callback to run immediately before the component is updated after any state change.\n *\n * The first time the callback runs will be before the initial `onMount`\n *\n * https://svelte.dev/docs#run-time-svelte-beforeupdate\n */\nfunction beforeUpdate(fn) {\n    get_current_component().$$.before_update.push(fn);\n}\n/**\n * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.\n * It must be called during the component's initialisation (but doesn't need to live *inside* the component;\n * it can be called from an external module).\n *\n * `onMount` does not run inside a [server-side component](/docs#run-time-server-side-component-api).\n *\n * https://svelte.dev/docs#run-time-svelte-onmount\n */\nfunction onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n}\n/**\n * Schedules a callback to run immediately after the component has been updated.\n *\n * The first time the callback runs will be after the initial `onMount`\n */\nfunction afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n}\n/**\n * Schedules a callback to run immediately before the component is unmounted.\n *\n * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the\n * only one that runs inside a server-side component.\n *\n * https://svelte.dev/docs#run-time-svelte-ondestroy\n */\nfunction onDestroy(fn) {\n    get_current_component().$$.on_destroy.push(fn);\n}\n/**\n * Creates an event dispatcher that can be used to dispatch [component events](/docs#template-syntax-component-directives-on-eventname).\n * Event dispatchers are functions that can take two arguments: `name` and `detail`.\n *\n * Component events created with `createEventDispatcher` create a\n * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).\n * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).\n * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)\n * property and can contain any type of data.\n *\n * https://svelte.dev/docs#run-time-svelte-createeventdispatcher\n */\nfunction createEventDispatcher() {\n    const component = get_current_component();\n    return (type, detail, { cancelable = false } = {}) => {\n        const callbacks = component.$$.callbacks[type];\n        if (callbacks) {\n            // TODO are there situations where events could be dispatched\n            // in a server (non-DOM) environment?\n            const event = custom_event(type, detail, { cancelable });\n            callbacks.slice().forEach(fn => {\n                fn.call(component, event);\n            });\n            return !event.defaultPrevented;\n        }\n        return true;\n    };\n}\n/**\n * Associates an arbitrary `context` object with the current component and the specified `key`\n * and returns that object. The context is then available to children of the component\n * (including slotted content) with `getContext`.\n *\n * Like lifecycle functions, this must be called during component initialisation.\n *\n * https://svelte.dev/docs#run-time-svelte-setcontext\n */\nfunction setContext(key, context) {\n    get_current_component().$$.context.set(key, context);\n    return context;\n}\n/**\n * Retrieves the context that belongs to the closest parent component with the specified `key`.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs#run-time-svelte-getcontext\n */\nfunction getContext(key) {\n    return get_current_component().$$.context.get(key);\n}\n/**\n * Retrieves the whole context map that belongs to the closest parent component.\n * Must be called during component initialisation. Useful, for example, if you\n * programmatically create a component and want to pass the existing context to it.\n *\n * https://svelte.dev/docs#run-time-svelte-getallcontexts\n */\nfunction getAllContexts() {\n    return get_current_component().$$.context;\n}\n/**\n * Checks whether a given `key` has been set in the context of a parent component.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs#run-time-svelte-hascontext\n */\nfunction hasContext(key) {\n    return get_current_component().$$.context.has(key);\n}\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\nfunction bubble(component, event) {\n    const callbacks = component.$$.callbacks[event.type];\n    if (callbacks) {\n        // @ts-ignore\n        callbacks.slice().forEach(fn => fn.call(this, event));\n    }\n}\n\nconst dirty_components = [];\nconst intros = { enabled: false };\nconst binding_callbacks = [];\nlet render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = /* @__PURE__ */ Promise.resolve();\nlet update_scheduled = false;\nfunction schedule_update() {\n    if (!update_scheduled) {\n        update_scheduled = true;\n        resolved_promise.then(flush);\n    }\n}\nfunction tick() {\n    schedule_update();\n    return resolved_promise;\n}\nfunction add_render_callback(fn) {\n    render_callbacks.push(fn);\n}\nfunction add_flush_callback(fn) {\n    flush_callbacks.push(fn);\n}\n// flush() calls callbacks in this order:\n// 1. All beforeUpdate callbacks, in order: parents before children\n// 2. All bind:this callbacks, in reverse order: children before parents.\n// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT\n//    for afterUpdates called during the initial onMount, which are called in\n//    reverse order: children before parents.\n// Since callbacks might update component values, which could trigger another\n// call to flush(), the following steps guard against this:\n// 1. During beforeUpdate, any updated components will be added to the\n//    dirty_components array and will cause a reentrant call to flush(). Because\n//    the flush index is kept outside the function, the reentrant call will pick\n//    up where the earlier call left off and go through all dirty components. The\n//    current_component value is saved and restored so that the reentrant call will\n//    not interfere with the \"parent\" flush() call.\n// 2. bind:this callbacks cannot trigger new flush() calls.\n// 3. During afterUpdate, any updated components will NOT have their afterUpdate\n//    callback called a second time; the seen_callbacks set, outside the flush()\n//    function, guarantees this behavior.\nconst seen_callbacks = new Set();\nlet flushidx = 0; // Do *not* move this inside the flush() function\nfunction flush() {\n    // Do not reenter flush while dirty components are updated, as this can\n    // result in an infinite loop. Instead, let the inner flush handle it.\n    // Reentrancy is ok afterwards for bindings etc.\n    if (flushidx !== 0) {\n        return;\n    }\n    const saved_component = current_component;\n    do {\n        // first, call beforeUpdate functions\n        // and update components\n        try {\n            while (flushidx < dirty_components.length) {\n                const component = dirty_components[flushidx];\n                flushidx++;\n                set_current_component(component);\n                update(component.$$);\n            }\n        }\n        catch (e) {\n            // reset dirty state to not end up in a deadlocked state and then rethrow\n            dirty_components.length = 0;\n            flushidx = 0;\n            throw e;\n        }\n        set_current_component(null);\n        dirty_components.length = 0;\n        flushidx = 0;\n        while (binding_callbacks.length)\n            binding_callbacks.pop()();\n        // then, once components are updated, call\n        // afterUpdate functions. This may cause\n        // subsequent updates...\n        for (let i = 0; i < render_callbacks.length; i += 1) {\n            const callback = render_callbacks[i];\n            if (!seen_callbacks.has(callback)) {\n                // ...so guard against infinite loops\n                seen_callbacks.add(callback);\n                callback();\n            }\n        }\n        render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n        flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    seen_callbacks.clear();\n    set_current_component(saved_component);\n}\nfunction update($$) {\n    if ($$.fragment !== null) {\n        $$.update();\n        run_all($$.before_update);\n        const dirty = $$.dirty;\n        $$.dirty = [-1];\n        $$.fragment && $$.fragment.p($$.ctx, dirty);\n        $$.after_update.forEach(add_render_callback);\n    }\n}\n/**\n * Useful for example to execute remaining `afterUpdate` callbacks before executing `destroy`.\n */\nfunction flush_render_callbacks(fns) {\n    const filtered = [];\n    const targets = [];\n    render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n    targets.forEach((c) => c());\n    render_callbacks = filtered;\n}\n\nlet promise;\nfunction wait() {\n    if (!promise) {\n        promise = Promise.resolve();\n        promise.then(() => {\n            promise = null;\n        });\n    }\n    return promise;\n}\nfunction dispatch(node, direction, kind) {\n    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\nconst outroing = new Set();\nlet outros;\nfunction group_outros() {\n    outros = {\n        r: 0,\n        c: [],\n        p: outros // parent group\n    };\n}\nfunction check_outros() {\n    if (!outros.r) {\n        run_all(outros.c);\n    }\n    outros = outros.p;\n}\nfunction transition_in(block, local) {\n    if (block && block.i) {\n        outroing.delete(block);\n        block.i(local);\n    }\n}\nfunction transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n        if (outroing.has(block))\n            return;\n        outroing.add(block);\n        outros.c.push(() => {\n            outroing.delete(block);\n            if (callback) {\n                if (detach)\n                    block.d(1);\n                callback();\n            }\n        });\n        block.o(local);\n    }\n    else if (callback) {\n        callback();\n    }\n}\nconst null_transition = { duration: 0 };\nfunction create_in_transition(node, fn, params) {\n    const options = { direction: 'in' };\n    let config = fn(node, params, options);\n    let running = false;\n    let animation_name;\n    let task;\n    let uid = 0;\n    function cleanup() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n        tick(0, 1);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        if (task)\n            task.abort();\n        running = true;\n        add_render_callback(() => dispatch(node, true, 'start'));\n        task = loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(1, 0);\n                    dispatch(node, true, 'end');\n                    cleanup();\n                    return running = false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(t, 1 - t);\n                }\n            }\n            return running;\n        });\n    }\n    let started = false;\n    return {\n        start() {\n            if (started)\n                return;\n            started = true;\n            delete_rule(node);\n            if (is_function(config)) {\n                config = config(options);\n                wait().then(go);\n            }\n            else {\n                go();\n            }\n        },\n        invalidate() {\n            started = false;\n        },\n        end() {\n            if (running) {\n                cleanup();\n                running = false;\n            }\n        }\n    };\n}\nfunction create_out_transition(node, fn, params) {\n    const options = { direction: 'out' };\n    let config = fn(node, params, options);\n    let running = true;\n    let animation_name;\n    const group = outros;\n    group.r += 1;\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        add_render_callback(() => dispatch(node, false, 'start'));\n        loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(0, 1);\n                    dispatch(node, false, 'end');\n                    if (!--group.r) {\n                        // this will result in `end()` being called,\n                        // so we don't need to clean up here\n                        run_all(group.c);\n                    }\n                    return false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(1 - t, t);\n                }\n            }\n            return running;\n        });\n    }\n    if (is_function(config)) {\n        wait().then(() => {\n            // @ts-ignore\n            config = config(options);\n            go();\n        });\n    }\n    else {\n        go();\n    }\n    return {\n        end(reset) {\n            if (reset && config.tick) {\n                config.tick(1, 0);\n            }\n            if (running) {\n                if (animation_name)\n                    delete_rule(node, animation_name);\n                running = false;\n            }\n        }\n    };\n}\nfunction create_bidirectional_transition(node, fn, params, intro) {\n    const options = { direction: 'both' };\n    let config = fn(node, params, options);\n    let t = intro ? 0 : 1;\n    let running_program = null;\n    let pending_program = null;\n    let animation_name = null;\n    function clear_animation() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function init(program, duration) {\n        const d = (program.b - t);\n        duration *= Math.abs(d);\n        return {\n            a: t,\n            b: program.b,\n            d,\n            duration,\n            start: program.start,\n            end: program.start + duration,\n            group: program.group\n        };\n    }\n    function go(b) {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        const program = {\n            start: now() + delay,\n            b\n        };\n        if (!b) {\n            // @ts-ignore todo: improve typings\n            program.group = outros;\n            outros.r += 1;\n        }\n        if (running_program || pending_program) {\n            pending_program = program;\n        }\n        else {\n            // if this is an intro, and there's a delay, we need to do\n            // an initial tick and/or apply CSS animation immediately\n            if (css) {\n                clear_animation();\n                animation_name = create_rule(node, t, b, duration, delay, easing, css);\n            }\n            if (b)\n                tick(0, 1);\n            running_program = init(program, duration);\n            add_render_callback(() => dispatch(node, b, 'start'));\n            loop(now => {\n                if (pending_program && now > pending_program.start) {\n                    running_program = init(pending_program, duration);\n                    pending_program = null;\n                    dispatch(node, running_program.b, 'start');\n                    if (css) {\n                        clear_animation();\n                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n                    }\n                }\n                if (running_program) {\n                    if (now >= running_program.end) {\n                        tick(t = running_program.b, 1 - t);\n                        dispatch(node, running_program.b, 'end');\n                        if (!pending_program) {\n                            // we're done\n                            if (running_program.b) {\n                                // intro — we can tidy up immediately\n                                clear_animation();\n                            }\n                            else {\n                                // outro — needs to be coordinated\n                                if (!--running_program.group.r)\n                                    run_all(running_program.group.c);\n                            }\n                        }\n                        running_program = null;\n                    }\n                    else if (now >= running_program.start) {\n                        const p = now - running_program.start;\n                        t = running_program.a + running_program.d * easing(p / running_program.duration);\n                        tick(t, 1 - t);\n                    }\n                }\n                return !!(running_program || pending_program);\n            });\n        }\n    }\n    return {\n        run(b) {\n            if (is_function(config)) {\n                wait().then(() => {\n                    // @ts-ignore\n                    config = config(options);\n                    go(b);\n                });\n            }\n            else {\n                go(b);\n            }\n        },\n        end() {\n            clear_animation();\n            running_program = pending_program = null;\n        }\n    };\n}\n\nfunction handle_promise(promise, info) {\n    const token = info.token = {};\n    function update(type, index, key, value) {\n        if (info.token !== token)\n            return;\n        info.resolved = value;\n        let child_ctx = info.ctx;\n        if (key !== undefined) {\n            child_ctx = child_ctx.slice();\n            child_ctx[key] = value;\n        }\n        const block = type && (info.current = type)(child_ctx);\n        let needs_flush = false;\n        if (info.block) {\n            if (info.blocks) {\n                info.blocks.forEach((block, i) => {\n                    if (i !== index && block) {\n                        group_outros();\n                        transition_out(block, 1, 1, () => {\n                            if (info.blocks[i] === block) {\n                                info.blocks[i] = null;\n                            }\n                        });\n                        check_outros();\n                    }\n                });\n            }\n            else {\n                info.block.d(1);\n            }\n            block.c();\n            transition_in(block, 1);\n            block.m(info.mount(), info.anchor);\n            needs_flush = true;\n        }\n        info.block = block;\n        if (info.blocks)\n            info.blocks[index] = block;\n        if (needs_flush) {\n            flush();\n        }\n    }\n    if (is_promise(promise)) {\n        const current_component = get_current_component();\n        promise.then(value => {\n            set_current_component(current_component);\n            update(info.then, 1, info.value, value);\n            set_current_component(null);\n        }, error => {\n            set_current_component(current_component);\n            update(info.catch, 2, info.error, error);\n            set_current_component(null);\n            if (!info.hasCatch) {\n                throw error;\n            }\n        });\n        // if we previously had a then/catch block, destroy it\n        if (info.current !== info.pending) {\n            update(info.pending, 0);\n            return true;\n        }\n    }\n    else {\n        if (info.current !== info.then) {\n            update(info.then, 1, info.value, promise);\n            return true;\n        }\n        info.resolved = promise;\n    }\n}\nfunction update_await_block_branch(info, ctx, dirty) {\n    const child_ctx = ctx.slice();\n    const { resolved } = info;\n    if (info.current === info.then) {\n        child_ctx[info.value] = resolved;\n    }\n    if (info.current === info.catch) {\n        child_ctx[info.error] = resolved;\n    }\n    info.block.p(child_ctx, dirty);\n}\n\nconst globals = (typeof window !== 'undefined'\n    ? window\n    : typeof globalThis !== 'undefined'\n        ? globalThis\n        : global);\n\nfunction destroy_block(block, lookup) {\n    block.d(1);\n    lookup.delete(block.key);\n}\nfunction outro_and_destroy_block(block, lookup) {\n    transition_out(block, 1, 1, () => {\n        lookup.delete(block.key);\n    });\n}\nfunction fix_and_destroy_block(block, lookup) {\n    block.f();\n    destroy_block(block, lookup);\n}\nfunction fix_and_outro_and_destroy_block(block, lookup) {\n    block.f();\n    outro_and_destroy_block(block, lookup);\n}\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n    let o = old_blocks.length;\n    let n = list.length;\n    let i = o;\n    const old_indexes = {};\n    while (i--)\n        old_indexes[old_blocks[i].key] = i;\n    const new_blocks = [];\n    const new_lookup = new Map();\n    const deltas = new Map();\n    const updates = [];\n    i = n;\n    while (i--) {\n        const child_ctx = get_context(ctx, list, i);\n        const key = get_key(child_ctx);\n        let block = lookup.get(key);\n        if (!block) {\n            block = create_each_block(key, child_ctx);\n            block.c();\n        }\n        else if (dynamic) {\n            // defer updates until all the DOM shuffling is done\n            updates.push(() => block.p(child_ctx, dirty));\n        }\n        new_lookup.set(key, new_blocks[i] = block);\n        if (key in old_indexes)\n            deltas.set(key, Math.abs(i - old_indexes[key]));\n    }\n    const will_move = new Set();\n    const did_move = new Set();\n    function insert(block) {\n        transition_in(block, 1);\n        block.m(node, next);\n        lookup.set(block.key, block);\n        next = block.first;\n        n--;\n    }\n    while (o && n) {\n        const new_block = new_blocks[n - 1];\n        const old_block = old_blocks[o - 1];\n        const new_key = new_block.key;\n        const old_key = old_block.key;\n        if (new_block === old_block) {\n            // do nothing\n            next = new_block.first;\n            o--;\n            n--;\n        }\n        else if (!new_lookup.has(old_key)) {\n            // remove old block\n            destroy(old_block, lookup);\n            o--;\n        }\n        else if (!lookup.has(new_key) || will_move.has(new_key)) {\n            insert(new_block);\n        }\n        else if (did_move.has(old_key)) {\n            o--;\n        }\n        else if (deltas.get(new_key) > deltas.get(old_key)) {\n            did_move.add(new_key);\n            insert(new_block);\n        }\n        else {\n            will_move.add(old_key);\n            o--;\n        }\n    }\n    while (o--) {\n        const old_block = old_blocks[o];\n        if (!new_lookup.has(old_block.key))\n            destroy(old_block, lookup);\n    }\n    while (n)\n        insert(new_blocks[n - 1]);\n    run_all(updates);\n    return new_blocks;\n}\nfunction validate_each_keys(ctx, list, get_context, get_key) {\n    const keys = new Set();\n    for (let i = 0; i < list.length; i++) {\n        const key = get_key(get_context(ctx, list, i));\n        if (keys.has(key)) {\n            throw new Error('Cannot have duplicate keys in a keyed each');\n        }\n        keys.add(key);\n    }\n}\n\nfunction get_spread_update(levels, updates) {\n    const update = {};\n    const to_null_out = {};\n    const accounted_for = { $$scope: 1 };\n    let i = levels.length;\n    while (i--) {\n        const o = levels[i];\n        const n = updates[i];\n        if (n) {\n            for (const key in o) {\n                if (!(key in n))\n                    to_null_out[key] = 1;\n            }\n            for (const key in n) {\n                if (!accounted_for[key]) {\n                    update[key] = n[key];\n                    accounted_for[key] = 1;\n                }\n            }\n            levels[i] = n;\n        }\n        else {\n            for (const key in o) {\n                accounted_for[key] = 1;\n            }\n        }\n    }\n    for (const key in to_null_out) {\n        if (!(key in update))\n            update[key] = undefined;\n    }\n    return update;\n}\nfunction get_spread_object(spread_props) {\n    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n\nconst _boolean_attributes = [\n    'allowfullscreen',\n    'allowpaymentrequest',\n    'async',\n    'autofocus',\n    'autoplay',\n    'checked',\n    'controls',\n    'default',\n    'defer',\n    'disabled',\n    'formnovalidate',\n    'hidden',\n    'inert',\n    'ismap',\n    'loop',\n    'multiple',\n    'muted',\n    'nomodule',\n    'novalidate',\n    'open',\n    'playsinline',\n    'readonly',\n    'required',\n    'reversed',\n    'selected'\n];\n/**\n * List of HTML boolean attributes (e.g. `<input disabled>`).\n * Source: https://html.spec.whatwg.org/multipage/indices.html\n */\nconst boolean_attributes = new Set([..._boolean_attributes]);\n\n/** regex of all html void element names */\nconst void_element_names = /^(?:area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/;\nfunction is_void(name) {\n    return void_element_names.test(name) || name.toLowerCase() === '!doctype';\n}\n\nconst invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nfunction spread(args, attrs_to_add) {\n    const attributes = Object.assign({}, ...args);\n    if (attrs_to_add) {\n        const classes_to_add = attrs_to_add.classes;\n        const styles_to_add = attrs_to_add.styles;\n        if (classes_to_add) {\n            if (attributes.class == null) {\n                attributes.class = classes_to_add;\n            }\n            else {\n                attributes.class += ' ' + classes_to_add;\n            }\n        }\n        if (styles_to_add) {\n            if (attributes.style == null) {\n                attributes.style = style_object_to_string(styles_to_add);\n            }\n            else {\n                attributes.style = style_object_to_string(merge_ssr_styles(attributes.style, styles_to_add));\n            }\n        }\n    }\n    let str = '';\n    Object.keys(attributes).forEach(name => {\n        if (invalid_attribute_name_character.test(name))\n            return;\n        const value = attributes[name];\n        if (value === true)\n            str += ' ' + name;\n        else if (boolean_attributes.has(name.toLowerCase())) {\n            if (value)\n                str += ' ' + name;\n        }\n        else if (value != null) {\n            str += ` ${name}=\"${value}\"`;\n        }\n    });\n    return str;\n}\nfunction merge_ssr_styles(style_attribute, style_directive) {\n    const style_object = {};\n    for (const individual_style of style_attribute.split(';')) {\n        const colon_index = individual_style.indexOf(':');\n        const name = individual_style.slice(0, colon_index).trim();\n        const value = individual_style.slice(colon_index + 1).trim();\n        if (!name)\n            continue;\n        style_object[name] = value;\n    }\n    for (const name in style_directive) {\n        const value = style_directive[name];\n        if (value) {\n            style_object[name] = value;\n        }\n        else {\n            delete style_object[name];\n        }\n    }\n    return style_object;\n}\nconst ATTR_REGEX = /[&\"]/g;\nconst CONTENT_REGEX = /[&<]/g;\n/**\n * Note: this method is performance sensitive and has been optimized\n * https://github.com/sveltejs/svelte/pull/5701\n */\nfunction escape(value, is_attr = false) {\n    const str = String(value);\n    const pattern = is_attr ? ATTR_REGEX : CONTENT_REGEX;\n    pattern.lastIndex = 0;\n    let escaped = '';\n    let last = 0;\n    while (pattern.test(str)) {\n        const i = pattern.lastIndex - 1;\n        const ch = str[i];\n        escaped += str.substring(last, i) + (ch === '&' ? '&amp;' : (ch === '\"' ? '&quot;' : '&lt;'));\n        last = i + 1;\n    }\n    return escaped + str.substring(last);\n}\nfunction escape_attribute_value(value) {\n    // keep booleans, null, and undefined for the sake of `spread`\n    const should_escape = typeof value === 'string' || (value && typeof value === 'object');\n    return should_escape ? escape(value, true) : value;\n}\nfunction escape_object(obj) {\n    const result = {};\n    for (const key in obj) {\n        result[key] = escape_attribute_value(obj[key]);\n    }\n    return result;\n}\nfunction each(items, fn) {\n    let str = '';\n    for (let i = 0; i < items.length; i += 1) {\n        str += fn(items[i], i);\n    }\n    return str;\n}\nconst missing_component = {\n    $$render: () => ''\n};\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === 'svelte:component')\n            name += ' this={...}';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules. Otherwise you may need to fix a <${name}>.`);\n    }\n    return component;\n}\nfunction debug(file, line, column, values) {\n    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n    console.log(values); // eslint-disable-line no-console\n    return '';\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots, context) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(context || (parent_component ? parent_component.$$.context : [])),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {\n            on_destroy = [];\n            const result = { title: '', head: '', css: new Set() };\n            const html = $$render(result, props, {}, $$slots, context);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.title + result.head\n            };\n        },\n        $$render\n    };\n}\nfunction add_attribute(name, value, boolean) {\n    if (value == null || (boolean && !value))\n        return '';\n    const assignment = (boolean && value === true) ? '' : `=\"${escape(value, true)}\"`;\n    return ` ${name}${assignment}`;\n}\nfunction add_classes(classes) {\n    return classes ? ` class=\"${classes}\"` : '';\n}\nfunction style_object_to_string(style_object) {\n    return Object.keys(style_object)\n        .filter(key => style_object[key])\n        .map(key => `${key}: ${escape_attribute_value(style_object[key])};`)\n        .join(' ');\n}\nfunction add_styles(style_object) {\n    const styles = style_object_to_string(style_object);\n    return styles ? ` style=\"${styles}\"` : '';\n}\n\nfunction bind(component, name, callback) {\n    const index = component.$$.props[name];\n    if (index !== undefined) {\n        component.$$.bound[index] = callback;\n        callback(component.$$.ctx[index]);\n    }\n}\nfunction create_component(block) {\n    block && block.c();\n}\nfunction claim_component(block, parent_nodes) {\n    block && block.l(parent_nodes);\n}\nfunction mount_component(component, target, anchor, customElement) {\n    const { fragment, after_update } = component.$$;\n    fragment && fragment.m(target, anchor);\n    if (!customElement) {\n        // onMount happens before the initial afterUpdate\n        add_render_callback(() => {\n            const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n            // if the component was destroyed immediately\n            // it will update the `$$.on_destroy` reference to `null`.\n            // the destructured on_destroy may still reference to the old array\n            if (component.$$.on_destroy) {\n                component.$$.on_destroy.push(...new_on_destroy);\n            }\n            else {\n                // Edge case - component was destroyed immediately,\n                // most likely as a result of a binding initialising\n                run_all(new_on_destroy);\n            }\n            component.$$.on_mount = [];\n        });\n    }\n    after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n    const $$ = component.$$;\n    if ($$.fragment !== null) {\n        flush_render_callbacks($$.after_update);\n        run_all($$.on_destroy);\n        $$.fragment && $$.fragment.d(detaching);\n        // TODO null out other refs, including component.$$ (but need to\n        // preserve final state?)\n        $$.on_destroy = $$.fragment = null;\n        $$.ctx = [];\n    }\n}\nfunction make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n        dirty_components.push(component);\n        schedule_update();\n        component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const $$ = component.$$ = {\n        fragment: null,\n        ctx: [],\n        // state\n        props,\n        update: noop,\n        not_equal,\n        bound: blank_object(),\n        // lifecycle\n        on_mount: [],\n        on_destroy: [],\n        on_disconnect: [],\n        before_update: [],\n        after_update: [],\n        context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n        // everything else\n        callbacks: blank_object(),\n        dirty,\n        skip_bound: false,\n        root: options.target || parent_component.$$.root\n    };\n    append_styles && append_styles($$.root);\n    let ready = false;\n    $$.ctx = instance\n        ? instance(component, options.props || {}, (i, ret, ...rest) => {\n            const value = rest.length ? rest[0] : ret;\n            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                if (!$$.skip_bound && $$.bound[i])\n                    $$.bound[i](value);\n                if (ready)\n                    make_dirty(component, i);\n            }\n            return ret;\n        })\n        : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    // `false` as a special case of no DOM component\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n        if (options.hydrate) {\n            start_hydrating();\n            const nodes = children(options.target);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.l(nodes);\n            nodes.forEach(detach);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.c();\n        }\n        if (options.intro)\n            transition_in(component.$$.fragment);\n        mount_component(component, options.target, options.anchor, options.customElement);\n        end_hydrating();\n        flush();\n    }\n    set_current_component(parent_component);\n}\nlet SvelteElement;\nif (typeof HTMLElement === 'function') {\n    SvelteElement = class extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n        }\n        connectedCallback() {\n            const { on_mount } = this.$$;\n            this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n            // @ts-ignore todo: improve typings\n            for (const key in this.$$.slotted) {\n                // @ts-ignore todo: improve typings\n                this.appendChild(this.$$.slotted[key]);\n            }\n        }\n        attributeChangedCallback(attr, _oldValue, newValue) {\n            this[attr] = newValue;\n        }\n        disconnectedCallback() {\n            run_all(this.$$.on_disconnect);\n        }\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            // TODO should this delegate to addEventListener?\n            if (!is_function(callback)) {\n                return noop;\n            }\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set($$props) {\n            if (this.$$set && !is_empty($$props)) {\n                this.$$.skip_bound = true;\n                this.$$set($$props);\n                this.$$.skip_bound = false;\n            }\n        }\n    };\n}\n/**\n * Base class for Svelte components. Used when dev=false.\n */\nclass SvelteComponent {\n    $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n    }\n    $on(type, callback) {\n        if (!is_function(callback)) {\n            return noop;\n        }\n        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n        callbacks.push(callback);\n        return () => {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1)\n                callbacks.splice(index, 1);\n        };\n    }\n    $set($$props) {\n        if (this.$$set && !is_empty($$props)) {\n            this.$$.skip_bound = true;\n            this.$$set($$props);\n            this.$$.skip_bound = false;\n        }\n    }\n}\n\nfunction dispatch_dev(type, detail) {\n    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.58.0' }, detail), { bubbles: true }));\n}\nfunction append_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append(target, node);\n}\nfunction append_hydration_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append_hydration(target, node);\n}\nfunction insert_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert(target, node, anchor);\n}\nfunction insert_hydration_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert_hydration(target, node, anchor);\n}\nfunction detach_dev(node) {\n    dispatch_dev('SvelteDOMRemove', { node });\n    detach(node);\n}\nfunction detach_between_dev(before, after) {\n    while (before.nextSibling && before.nextSibling !== after) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction detach_before_dev(after) {\n    while (after.previousSibling) {\n        detach_dev(after.previousSibling);\n    }\n}\nfunction detach_after_dev(before) {\n    while (before.nextSibling) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation, has_stop_immediate_propagation) {\n    const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];\n    if (has_prevent_default)\n        modifiers.push('preventDefault');\n    if (has_stop_propagation)\n        modifiers.push('stopPropagation');\n    if (has_stop_immediate_propagation)\n        modifiers.push('stopImmediatePropagation');\n    dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });\n    const dispose = listen(node, event, handler, options);\n    return () => {\n        dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });\n        dispose();\n    };\n}\nfunction attr_dev(node, attribute, value) {\n    attr(node, attribute, value);\n    if (value == null)\n        dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });\n    else\n        dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });\n}\nfunction prop_dev(node, property, value) {\n    node[property] = value;\n    dispatch_dev('SvelteDOMSetProperty', { node, property, value });\n}\nfunction dataset_dev(node, property, value) {\n    node.dataset[property] = value;\n    dispatch_dev('SvelteDOMSetDataset', { node, property, value });\n}\nfunction set_data_dev(text, data) {\n    data = '' + data;\n    if (text.data === data)\n        return;\n    dispatch_dev('SvelteDOMSetData', { node: text, data });\n    text.data = data;\n}\nfunction set_data_contenteditable_dev(text, data) {\n    data = '' + data;\n    if (text.wholeText === data)\n        return;\n    dispatch_dev('SvelteDOMSetData', { node: text, data });\n    text.data = data;\n}\nfunction set_data_maybe_contenteditable_dev(text, data, attr_value) {\n    if (~contenteditable_truthy_values.indexOf(attr_value)) {\n        set_data_contenteditable_dev(text, data);\n    }\n    else {\n        set_data_dev(text, data);\n    }\n}\nfunction validate_each_argument(arg) {\n    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {\n        let msg = '{#each} only iterates over array-like objects.';\n        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {\n            msg += ' You can use a spread to convert this iterable into an array.';\n        }\n        throw new Error(msg);\n    }\n}\nfunction validate_slots(name, slot, keys) {\n    for (const slot_key of Object.keys(slot)) {\n        if (!~keys.indexOf(slot_key)) {\n            console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n        }\n    }\n}\nfunction validate_dynamic_element(tag) {\n    const is_string = typeof tag === 'string';\n    if (tag && !is_string) {\n        throw new Error('<svelte:element> expects \"this\" attribute to be a string.');\n    }\n}\nfunction validate_void_dynamic_element(tag) {\n    if (tag && is_void(tag)) {\n        console.warn(`<svelte:element this=\"${tag}\"> is self-closing and cannot have content.`);\n    }\n}\nfunction construct_svelte_component_dev(component, props) {\n    const error_message = 'this={...} of <svelte:component> should specify a Svelte component.';\n    try {\n        const instance = new component(props);\n        if (!instance.$$ || !instance.$set || !instance.$on || !instance.$destroy) {\n            throw new Error(error_message);\n        }\n        return instance;\n    }\n    catch (err) {\n        const { message } = err;\n        if (typeof message === 'string' && message.indexOf('is not a constructor') !== -1) {\n            throw new Error(error_message);\n        }\n        else {\n            throw err;\n        }\n    }\n}\n/**\n * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.\n */\nclass SvelteComponentDev extends SvelteComponent {\n    constructor(options) {\n        if (!options || (!options.target && !options.$$inline)) {\n            throw new Error(\"'target' is a required option\");\n        }\n        super();\n    }\n    $destroy() {\n        super.$destroy();\n        this.$destroy = () => {\n            console.warn('Component was already destroyed'); // eslint-disable-line no-console\n        };\n    }\n    $capture_state() { }\n    $inject_state() { }\n}\n/**\n * Base class to create strongly typed Svelte components.\n * This only exists for typing purposes and should be used in `.d.ts` files.\n *\n * ### Example:\n *\n * You have component library on npm called `component-library`, from which\n * you export a component called `MyComponent`. For Svelte+TypeScript users,\n * you want to provide typings. Therefore you create a `index.d.ts`:\n * ```ts\n * import { SvelteComponentTyped } from \"svelte\";\n * export class MyComponent extends SvelteComponentTyped<{foo: string}> {}\n * ```\n * Typing this makes it possible for IDEs like VS Code with the Svelte extension\n * to provide intellisense and to use the component like this in a Svelte file\n * with TypeScript:\n * ```svelte\n * <script lang=\"ts\">\n * \timport { MyComponent } from \"component-library\";\n * </script>\n * <MyComponent foo={'bar'} />\n * ```\n *\n * #### Why not make this part of `SvelteComponent(Dev)`?\n * Because\n * ```ts\n * class ASubclassOfSvelteComponent extends SvelteComponent<{foo: string}> {}\n * const component: typeof SvelteComponent = ASubclassOfSvelteComponent;\n * ```\n * will throw a type error, so we need to separate the more strictly typed class.\n */\nclass SvelteComponentTyped extends SvelteComponentDev {\n    constructor(options) {\n        super(options);\n    }\n}\nfunction loop_guard(timeout) {\n    const start = Date.now();\n    return () => {\n        if (Date.now() - start > timeout) {\n            throw new Error('Infinite loop detected');\n        }\n    };\n}\n\n\n\n\n//# sourceURL=webpack://aperta/./node_modules/svelte/internal/index.mjs?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./views/webdesign.js");
/******/ 	
/******/ })()
;